    1                   ;       EMUBASIC based on GRANT's BASIC
    2                   ;       TARGET: EMUZ80
    3                   ;       ASSEMBLER: ARCPIT XZ80.EXE
    4                   ;
    5                   ;       START UP ROUTINE
    6                   ;       VERSION 1.0, 2022/02/15
    7                   ;       WRITTEN by TETSUYA SUZUKI
    8                   ;
    9                   ;       MEMORY ASIGN
   10 0000              ROMTOP     EQU      0000H
   11 8000              RAMTOP     EQU      8000H
   12 1000              RAMSIZ     EQU      1000H
   13 80ED              TSTACK     EQU      80EDH
   14                   ;
   15                   ;       UART REGISTER ADDRESS
   16 E000              UARTDR     EQU      0E000H      ; UART DATA REGISTOR
   17 E001              UARTCR     EQU      0E001H      ; UART CONTROL REGISTOR
   18                   ;
   19                   ;       RESET (RST 00H)
   20 0000                         ORG      ROMTOP
   21 0000 F3                      DI
   22 0001 31ED80                  LD       SP,TSTACK
   23 0004 C34100                  JP       SINIT
   24                   ;
   25                   ;       PUT 1CHAR (RST 08H)
   26 0008                         ORG      ROMTOP+08H
   27 0008 C33400                  JP       TXA
   28                   ;
   29                   ;       GET 1CHAR (RST 10H)
   30 0010                         ORG      ROMTOP+10H
   31 0010 C31B00                  JP       RXA
   32                   ;
   33                   ;       KBHIT (RST 18H)
   34 0018                         ORG      ROMTOP+18H
   35 0018 C32E00                  JP       KBHIT
   36                   ;
   37                   ;       UART -> A
   38 001B 3A01E0       RXA:       LD       A,(UARTCR)
   39 001E CB47                    BIT      0,A
   40 0020 28F9                    JR       Z,RXA
   41 0022 3A00E0                  LD       A,(UARTDR)
   42 0025 FE61                    CP       'a'
   43 0027 D8                      RET      C
   44 0028 FE7B                    CP       'z'+1
   45 002A D0                      RET      NC
   46 002B E6DF                    AND      0DFH
   47 002D C9                      RET
   48                   ;
   49                   ;       CHECK RECEIVE STATUS
   50 002E 3A01E0       KBHIT:     LD       A,(UARTCR)
   51 0031 CB47                    BIT      0,A
   52 0033 C9                      RET
   53                   ;
   54                   ;       A -> UART
   55 0034 F5           TXA:       PUSH     AF
   56 0035 3A01E0       TXAST1:    LD       A,(UARTCR)
   57 0038 CB4F                    BIT      1,A
   58 003A 28F9                    JR       Z,TXAST1
   59 003C F1                      POP      AF
   60 003D 3200E0                  LD       (UARTDR),A
   61 0040 C9                      RET
   62                   ;
   63                   ;
   64                   ;       SYSTEM INITIALIZE
   65 0041              SINIT:
   66 0041 C34400                  JP       COLD
   67                   ;
   68                   ;======================================================
   69                   ; The updates to the original BASIC within this file ar
   70                   ;
   71                   ; You have permission to use this for NON COMMERCIAL US
   72                   ; If you wish to use it elsewhere, please include an ac
   73                   ;
   74                   ; http://searle.hostei.com/grant/index.html
   75                   ;
   76                   ; eMail: home.micros01@btinternet.com
   77                   ;
   78                   ; If the above don't work, please perform an Internet s
   79                   ; updated the web page hosting service.
   80                   ;
   81                   ;======================================================
   82                   ;
   83                   ; NASCOM ROM BASIC Ver 4.7, (C) 1978 Microsoft
   84                   ; Scanned from source published in 80-BUS NEWS from Vol
   85                   ; (May-June 1983) to Vol 3, Issue 3 (May-June 1984)
   86                   ; Adapted for the freeware Zilog Macro Assembler 2.10 t
   87                   ; the original ROM code (checksum A934H). PA
   88                   ;
   89                   ; GENERAL EQUATES
   90                   ;
   91 0003              CTRLC      EQU      03H         ; Control "C"
   92 0007              CTRLG      EQU      07H         ; Control "G"
   93 0008              BKSP       EQU      08H         ; Back space
   94 000A              LF         EQU      0AH         ; Line feed
   95 000C              CS         EQU      0CH         ; Clear screen
   96 000D              CR         EQU      0DH         ; Carriage return
   97 000F              CTRLO      EQU      0FH         ; Control "O"
   98 0011              CTRLQ      EQU      11H         ; Control "Q"
   99 0012              CTRLR      EQU      12H         ; Control "R"
  100 0013              CTRLS      EQU      13H         ; Control "S"
  101 0015              CTRLU      EQU      15H         ; Control "U"
  102 001B              ESC        EQU      1BH         ; Escape
  103 007F              DEL        EQU      7FH         ; Delete
  104                   ;
  105                   ; BASIC WORK SPACE LOCATIONS
  106                   ;
  107 8045              WRKSPC     EQU      8045H       ; BASIC Work space
  108 8048              USR        EQU      WRKSPC+3H   ; "USR (x)" jump
  109 804B              OUTSUB     EQU      WRKSPC+6H   ; "OUT p,n"
  110 804C              OTPORT     EQU      WRKSPC+7H   ; Port (p)
  111 804E              DIVSUP     EQU      WRKSPC+9H   ; Division support rout
  112 804F              DIV1       EQU      WRKSPC+0AH  ; <- Values
  113 8053              DIV2       EQU      WRKSPC+0EH  ; <- to
  114 8057              DIV3       EQU      WRKSPC+12H  ; <- be
  115 805A              DIV4       EQU      WRKSPC+15H  ; <- inserted
  116 805C              SEED       EQU      WRKSPC+17H  ; Random number seed
  117 807F              LSTRND     EQU      WRKSPC+3AH  ; Last random number
  118 8083              INPSUB     EQU      WRKSPC+3EH  ; #INP (x)" Routine
  119 8084              INPORT     EQU      WRKSPC+3FH  ; PORT (x)
  120 8086              NULLS      EQU      WRKSPC+41H  ; Number of nulls
  121 8087              LWIDTH     EQU      WRKSPC+42H  ; Terminal width
  122 8088              COMMAN     EQU      WRKSPC+43H  ; Width for commas
  123 8089              NULFLG     EQU      WRKSPC+44H  ; Null after input byte
  124 808A              CTLOFG     EQU      WRKSPC+45H  ; Control "O" flag
  125 808B              LINESC     EQU      WRKSPC+46H  ; Lines counter
  126 808D              LINESN     EQU      WRKSPC+48H  ; Lines number
  127 808F              CHKSUM     EQU      WRKSPC+4AH  ; Array load/save check
  128 8091              NMIFLG     EQU      WRKSPC+4CH  ; Flag for NMI break ro
  129 8092              BRKFLG     EQU      WRKSPC+4DH  ; Break flag
  130 8093              RINPUT     EQU      WRKSPC+4EH  ; Input reflection
  131 8096              POINT      EQU      WRKSPC+51H  ; "POINT" reflection (u
  132 8099              PSET       EQU      WRKSPC+54H  ; "SET" reflection
  133 809C              RESET      EQU      WRKSPC+57H  ; "RESET" reflection
  134 809F              STRSPC     EQU      WRKSPC+5AH  ; Bottom of string spac
  135 80A1              LINEAT     EQU      WRKSPC+5CH  ; Current line number
  136 80A3              BASTXT     EQU      WRKSPC+5EH  ; Pointer to start of p
  137 80A6              BUFFER     EQU      WRKSPC+61H  ; Input buffer
  138 80AB              STACK      EQU      WRKSPC+66H  ; Initial stack
  139 80F0              CURPOS     EQU      WRKSPC+0ABH ; Character position on
  140 80F1              LCRFLG     EQU      WRKSPC+0ACH ; Locate/Create flag
  141 80F2              TYPE       EQU      WRKSPC+0ADH ; Data type flag
  142 80F3              DATFLG     EQU      WRKSPC+0AEH ; Literal statement fla
  143 80F4              LSTRAM     EQU      WRKSPC+0AFH ; Last available RAM
  144 80F6              TMSTPT     EQU      WRKSPC+0B1H ; Temporary string poin
  145 80F8              TMSTPL     EQU      WRKSPC+0B3H ; Temporary string pool
  146 8104              TMPSTR     EQU      WRKSPC+0BFH ; Temporary string
  147 8108              STRBOT     EQU      WRKSPC+0C3H ; Bottom of string spac
  148 810A              CUROPR     EQU      WRKSPC+0C5H ; Current operator in E
  149 810C              LOOPST     EQU      WRKSPC+0C7H ; First statement of lo
  150 810E              DATLIN     EQU      WRKSPC+0C9H ; Line of current DATA 
  151 8110              FORFLG     EQU      WRKSPC+0CBH ; "FOR" loop flag
  152 8111              LSTBIN     EQU      WRKSPC+0CCH ; Last byte entered
  153 8112              READFG     EQU      WRKSPC+0CDH ; Read/Input flag
  154 8113              BRKLIN     EQU      WRKSPC+0CEH ; Line of break
  155 8115              NXTOPR     EQU      WRKSPC+0D0H ; Next operator in EVAL
  156 8117              ERRLIN     EQU      WRKSPC+0D2H ; Line of error
  157 8119              CONTAD     EQU      WRKSPC+0D4H ; Where to CONTinue
  158 811B              PROGND     EQU      WRKSPC+0D6H ; End of program
  159 811D              VAREND     EQU      WRKSPC+0D8H ; End of variables
  160 811F              ARREND     EQU      WRKSPC+0DAH ; End of arrays
  161 8121              NXTDAT     EQU      WRKSPC+0DCH ; Next data item
  162 8123              FNRGNM     EQU      WRKSPC+0DEH ; Name of FN argument
  163 8125              FNARG      EQU      WRKSPC+0E0H ; FN argument value
  164 8129              FPREG      EQU      WRKSPC+0E4H ; Floating point regist
  165 812C              FPEXP      EQU      FPREG+3     ; Floating point expone
  166 812D              SGNRES     EQU      WRKSPC+0E8H ; Sign of result
  167 812E              PBUFF      EQU      WRKSPC+0E9H ; Number print buffer
  168 813B              MULVAL     EQU      WRKSPC+0F6H ; Multiplier
  169 813E              PROGST     EQU      WRKSPC+0F9H ; Start of program text
  170 81A2              STLOOK     EQU      WRKSPC+15DH ; Start of memory test
  171                   ;
  172                   ; BASIC ERROR CODE VALUES
  173                   ;
  174 0000              NF         EQU      00H         ; NEXT without FOR
  175 0002              SN         EQU      02H         ; Syntax error
  176 0004              RG         EQU      04H         ; RETURN without GOSUB
  177 0006              OD         EQU      06H         ; Out of DATA
  178 0008              FC         EQU      08H         ; Function call error
  179 000A              OV         EQU      0AH         ; Overflow
  180 000C              OM         EQU      0CH         ; Out of memory
  181 000E              UL         EQU      0EH         ; Undefined line number
  182 0010              BS         EQU      10H         ; Bad subscript
  183 0012              RD         EQU      12H         ; Re-DIMensioned array
  184 0014              DZ         EQU      14H         ; Division by zero (/0)
  185 0016              ID         EQU      16H         ; Illegal direct
  186 0018              TM         EQU      18H         ; Type miss-match
  187 001A              OS         EQU      1AH         ; Out of string space
  188 001C              LS         EQU      1CH         ; String too long
  189 001E              ST         EQU      1EH         ; String formula too co
  190 0020              CN         EQU      20H         ; Can't CONTinue
  191 0022              UF         EQU      22H         ; UnDEFined FN function
  192 0024              MO         EQU      24H         ; Missing operand
  193 0026              HX         EQU      26H         ; HEX error
  194 0028              BN         EQU      28H         ; BIN error
  195                   ;
  196 0044 C34A00       COLD:      JP       STARTB      ; Jump for cold start
  197 0047 C3BF00       WARM:      JP       WARMST      ; Jump for warm start
  198 004A C35100       STARTB:    JP       CSTART      ; Jump to initialise
  199                   ;
  200 004D 0209                    DW       DEINT       ; Get integer -32768 to
  201 004F 7810                    DW       ABPASS      ; Return integer in AB
  202                   ;
  203 0051 214580       CSTART:    LD       HL,WRKSPC   ; Start of workspace RA
  204 0054 F9                      LD       SP,HL       ; Set up a temporary st
  205 0055 C3931C                  JP       INITST      ; Go to initialise
  206                   ;
  207 0058 112903       INIT:      LD       DE,INITAB   ; Initialise workspace
  208 005B 0663                    LD       B,INITBE-INITAB+3 ; Bytes to copy
  209 005D 214580                  LD       HL,WRKSPC   ; Into workspace RAM
  210 0060 1A           COPY:      LD       A,(DE)      ; Get source
  211 0061 77                      LD       (HL),A      ; To destination
  212 0062 23                      INC      HL          ; Next destination
  213 0063 13                      INC      DE          ; Next source
  214 0064 05                      DEC      B           ; Count bytes
  215 0065 C26000                  JP       NZ,COPY     ; More to move
  216 0068 F9                      LD       SP,HL       ; Temporary stack
  217 0069 CD2A05                  CALL     CLREG       ; Clear registers and s
  218 006C CDF80A                  CALL     PRCRLF      ; Output CRLF
  219 006F 32EF80                  LD       (BUFFER+72+1),A ; Mark end of buffe
  220 0072 323E81                  LD       (PROGST),A  ; Initialise program ar
  221 0075 21A281       MSIZE:     LD       HL,STLOOK   ; Point to start of RAM
  222 0078 23           MLOOP:     INC      HL          ; Next byte
  223 0079 7C                      LD       A,H         ; Above address FFFF ?
  224 007A B5                      OR       L
  225 007B CA8700                  JP       Z,SETTOP    ; Yes - 64K RAM
  226 007E 7E                      LD       A,(HL)      ; Get contents
  227 007F 47                      LD       B,A         ; Save it
  228 0080 2F                      CPL                  ; Flip all bits
  229 0081 77                      LD       (HL),A      ; Put it back
  230 0082 BE                      CP       (HL)        ; RAM there if same
  231 0083 70                      LD       (HL),B      ; Restore old contents
  232 0084 CA7800                  JP       Z,MLOOP     ; If RAM - test next by
  233                   ;
  234 0087 2B           SETTOP:    DEC      HL          ; Back one byte
  235 0088 11A181                  LD       DE,STLOOK-1 ; See if enough RAM
  236 008B CDC006                  CALL     CPDEHL      ; Compare DE with HL
  237 008E DAC800                  JP       C,NEMEM     ; If not enough RAM
  238 0091 11CEFF                  LD       DE,0-50     ; 50 Bytes string space
  239 0094 22F480                  LD       (LSTRAM),HL ; Save last available R
  240 0097 19                      ADD      HL,DE       ; Allocate string space
  241 0098 229F80                  LD       (STRSPC),HL ; Save string space
  242 009B CD0505                  CALL     CLRPTR      ; Clear program area
  243 009E 2A9F80                  LD       HL,(STRSPC) ; Get end of memory
  244 00A1 11EFFF                  LD       DE,0-17     ; Offset for free bytes
  245 00A4 19                      ADD      HL,DE       ; Adjust HL
  246 00A5 113E81                  LD       DE,PROGST   ; Start of program text
  247 00A8 7D                      LD       A,L         ; Get LSB
  248 00A9 93                      SUB      E           ; Adjust it
  249 00AA 6F                      LD       L,A         ; Re-save
  250 00AB 7C                      LD       A,H         ; Get MSB
  251 00AC 9A                      SBC      A,D         ; Adjust it
  252 00AD 67                      LD       H,A         ; Re-save
  253 00AE E5                      PUSH     HL          ; Save bytes free
  254 00AF 21E000                  LD       HL,SIGNON   ; Sign-on message
  255 00B2 CD9611                  CALL     PRS         ; Output string
  256 00B5 E1                      POP      HL          ; Get bytes free back
  257 00B6 CD3918                  CALL     PRNTHL      ; Output amount of free
  258 00B9 21D100                  LD       HL,BFREE    ; " Bytes free" message
  259 00BC CD9611                  CALL     PRS         ; Output string
  260                   ;
  261 00BF 31AB80       WARMST:    LD       SP,STACK    ; Temporary stack
  262 00C2 CD2A05       BRKRET:    CALL     CLREG       ; Clear registers and s
  263 00C5 C34304                  JP       PRNTOK      ; Go to get command lin
  264                   ;
  265 00C8 211701       NEMEM:     LD       HL,MEMMSG   ; Memory size not enoug
  266 00CB CD9611                  CALL     PRS         ; Print it
  267 00CE C3CE00       XXXXX:     JP       XXXXX       ; Stop
  268                   ;
  269 00D1 204279746573 BFREE:     DB       " Bytes free",CR,LF,0,0
           20667265650D 
           0A0000       
  270                   ;
  271 00E0 5A3830204241 SIGNON:    DB       "Z80 BASIC Ver 4.7b",CR,LF
           534943205665 
           7220342E3762 
           0D0A         
  272 00F4 436F70797269            DB       "Copyright ",40,"C",41
           676874202843 
           29           
  273 0101 203139373820            DB       " 1978 by Microsoft",CR,LF,0,0
           6279204D6963 
           726F736F6674 
           0D0A0000     
  274                   ;
  275 0117 4D656D6F7279 MEMMSG:    DB       "Memory size not enough",CR,LF
           2073697A6520 
           6E6F7420656E 
           6F7567680D0A 
  276 012F 546865207379            DB       "The system is stopped.",CR,LF,0,0
           7374656D2069 
           732073746F70 
           7065642E0D0A 
           0000         
  277                   ;
  278                   ; FUNCTION ADDRESS TABLE
  279                   ;
  280 0149 AE16         FNCTAB:    DW       SGN
  281 014B 7217                    DW       INT
  282 014D C416                    DW       ABS
  283 014F 4880                    DW       USR
  284 0151 5610                    DW       FRE
  285 0153 DB13                    DW       INP
  286 0155 8410                    DW       POS
  287 0157 3819                    DW       SQR
  288 0159 171A                    DW       RND
  289 015B 5315                    DW       LOG
  290 015D 8619                    DW       EXP
  291 015F 8C1A                    DW       COS
  292 0161 921A                    DW       SIN
  293 0163 F31A                    DW       TAN
  294 0165 081B                    DW       ATN
  295 0167 2F14                    DW       PEEK
  296 0169 731B                    DW       DEEK
  297 016B 9680                    DW       POINT
  298 016D 0813                    DW       LEN
  299 016F 2011                    DW       STR
  300 0171 A213                    DW       VAL
  301 0173 1713                    DW       ASC
  302 0175 2813                    DW       CHR
  303 0177 951B                    DW       HEX
  304 0179 281C                    DW       BIN
  305 017B 3813                    DW       LEFT
  306 017D 6813                    DW       RIGHT
  307 017F 7213                    DW       MID
  308                   ;
  309                   ; RESERVED WORD LIST
  310                   ;
  311 0181 C54E44       WORDS:     DB       0C5H,"ND"
  312 0184 C64F52                  DB       0C6H,"OR"
  313 0187 CE455854                DB       0CEH,"EXT"
  314 018B C4415441                DB       0C4H,"ATA"
  315 018F C94E505554              DB       0C9H,"NPUT"
  316 0194 C4494D                  DB       0C4H,"IM"
  317 0197 D2454144                DB       0D2H,"EAD"
  318 019B CC4554                  DB       0CCH,"ET"
  319 019E C74F544F                DB       0C7H,"OTO"
  320 01A2 D2554E                  DB       0D2H,"UN"
  321 01A5 C946                    DB       0C9H,"F"
  322 01A7 D24553544F52            DB       0D2H,"ESTORE"
           45           
  323 01AE C74F535542              DB       0C7H,"OSUB"
  324 01B3 D2455455524E            DB       0D2H,"ETURN"
  325 01B9 D2454D                  DB       0D2H,"EM"
  326 01BC D3544F50                DB       0D3H,"TOP"
  327 01C0 CF5554                  DB       0CFH,"UT"
  328 01C3 CF4E                    DB       0CFH,"N"
  329 01C5 CE554C4C                DB       0CEH,"ULL"
  330 01C9 D7414954                DB       0D7H,"AIT"
  331 01CD C44546                  DB       0C4H,"EF"
  332 01D0 D04F4B45                DB       0D0H,"OKE"
  333 01D4 C44F4B45                DB       0C4H,"OKE"
  334 01D8 D3435245454E            DB       0D3H,"CREEN"
  335 01DE CC494E4553              DB       0CCH,"INES"
  336 01E3 C34C53                  DB       0C3H,"LS"
  337 01E6 D749445448              DB       0D7H,"IDTH"
  338 01EB CD4F4E49544F            DB       0CDH,"ONITOR"
           52           
  339 01F2 D34554                  DB       0D3H,"ET"
  340 01F5 D245534554              DB       0D2H,"ESET"
  341 01FA D052494E54              DB       0D0H,"RINT"
  342 01FF C34F4E54                DB       0C3H,"ONT"
  343 0203 CC495354                DB       0CCH,"IST"
  344 0207 C34C454152              DB       0C3H,"LEAR"
  345 020C C34C4F4144              DB       0C3H,"LOAD"
  346 0211 C353415645              DB       0C3H,"SAVE"
  347 0216 CE4557                  DB       0CEH,"EW"
  348                   ;
  349 0219 D4414228                DB       0D4H,"AB("
  350 021D D44F                    DB       0D4H,"O"
  351 021F C64E                    DB       0C6H,"N"
  352 0221 D3504328                DB       0D3H,"PC("
  353 0225 D448454E                DB       0D4H,"HEN"
  354 0229 CE4F54                  DB       0CEH,"OT"
  355 022C D3544550                DB       0D3H,"TEP"
  356                   ;
  357 0230 AB                      DB       0ABH
  358 0231 AD                      DB       0ADH
  359 0232 AA                      DB       0AAH
  360 0233 AF                      DB       0AFH
  361 0234 DE                      DB       0DEH
  362 0235 C14E44                  DB       0C1H,"ND"
  363 0238 CF52                    DB       0CFH,"R"
  364 023A BE                      DB       0BEH
  365 023B BD                      DB       0BDH
  366 023C BC                      DB       0BCH
  367                   ;
  368 023D D3474E                  DB       0D3H,"GN"
  369 0240 C94E54                  DB       0C9H,"NT"
  370 0243 C14253                  DB       0C1H,"BS"
  371 0246 D55352                  DB       0D5H,"SR"
  372 0249 C65245                  DB       0C6H,"RE"
  373 024C C94E50                  DB       0C9H,"NP"
  374 024F D04F53                  DB       0D0H,"OS"
  375 0252 D35152                  DB       0D3H,"QR"
  376 0255 D24E44                  DB       0D2H,"ND"
  377 0258 CC4F47                  DB       0CCH,"OG"
  378 025B C55850                  DB       0C5H,"XP"
  379 025E C34F53                  DB       0C3H,"OS"
  380 0261 D3494E                  DB       0D3H,"IN"
  381 0264 D4414E                  DB       0D4H,"AN"
  382 0267 C1544E                  DB       0C1H,"TN"
  383 026A D045454B                DB       0D0H,"EEK"
  384 026E C445454B                DB       0C4H,"EEK"
  385 0272 D04F494E54              DB       0D0H,"OINT"
  386 0277 CC454E                  DB       0CCH,"EN"
  387 027A D3545224                DB       0D3H,"TR$"
  388 027E D6414C                  DB       0D6H,"AL"
  389 0281 C15343                  DB       0C1H,"SC"
  390 0284 C3485224                DB       0C3H,"HR$"
  391 0288 C8455824                DB       0C8H,"EX$"
  392 028C C2494E24                DB       0C2H,"IN$"
  393 0290 CC45465424              DB       0CCH,"EFT$"
  394 0295 D24947485424            DB       0D2H,"IGHT$"
  395 029B CD494424                DB       0CDH,"ID$"
  396 029F 80                      DB       80H         ; End of list marker
  397                   ;
  398                   ; KEYWORD ADDRESS TABLE
  399                   ;
  400 02A0 9A08         WORDTB:    DW       PEND
  401 02A2 9707                    DW       FOR
  402 02A4 720C                    DW       NEXT
  403 02A6 E709                    DW       DATA
  404 02A8 790B                    DW       INPUT
  405 02AA AE0E                    DW       DIM
  406 02AC A80B                    DW       READ
  407 02AE FE09                    DW       LET
  408 02B0 A409                    DW       GOTO
  409 02B2 8709                    DW       RUN
  410 02B4 760A                    DW       IF
  411 02B6 6008                    DW       RESTOR
  412 02B8 9309                    DW       GOSUB
  413 02BA C209                    DW       RETURN
  414 02BC E909                    DW       REM
  415 02BE 9808                    DW       STOP
  416 02C0 E713                    DW       POUT
  417 02C2 580A                    DW       ON
  418 02C4 D908                    DW       NULL
  419 02C6 ED13                    DW       WAIT
  420 02C8 8C10                    DW       DEF
  421 02CA 3614                    DW       POKE
  422 02CC 7E1B                    DW       DOKE
  423 02CE E909                    DW       REM
  424 02D0 641B                    DW       LINES
  425 02D2 571B                    DW       CLS
  426 02D4 5C1B                    DW       WIDTH
  427 02D6 901C                    DW       MONITR
  428 02D8 9980                    DW       PSET
  429 02DA 9C80                    DW       RESET
  430 02DC 9A0A                    DW       PRINT
  431 02DE C608                    DW       CONT
  432 02E0 0C07                    DW       LIST
  433 02E2 4109                    DW       CLEAR
  434 02E4 E909                    DW       REM
  435 02E6 E909                    DW       REM
  436 02E8 0405                    DW       NEW
  437                   ;
  438                   ; RESERVED WORD TOKEN VALUES
  439                   ;
  440 0080              ZEND       EQU      080H        ; END
  441 0081              ZFOR       EQU      081H        ; FOR
  442 0083              ZDATA      EQU      083H        ; DATA
  443 0088              ZGOTO      EQU      088H        ; GOTO
  444 008C              ZGOSUB     EQU      08CH        ; GOSUB
  445 008E              ZREM       EQU      08EH        ; REM
  446 009E              ZPRINT     EQU      09EH        ; PRINT
  447 00A4              ZNEW       EQU      0A4H        ; NEW
  448                   ;
  449 00A5              ZTAB       EQU      0A5H        ; TAB
  450 00A6              ZTO        EQU      0A6H        ; TO
  451 00A7              ZFN        EQU      0A7H        ; FN
  452 00A8              ZSPC       EQU      0A8H        ; SPC
  453 00A9              ZTHEN      EQU      0A9H        ; THEN
  454 00AA              ZNOT       EQU      0AAH        ; NOT
  455 00AB              ZSTEP      EQU      0ABH        ; STEP
  456                   ;
  457 00AC              ZPLUS      EQU      0ACH        ; +
  458 00AD              ZMINUS     EQU      0ADH        ; -
  459 00AE              ZTIMES     EQU      0AEH        ; *
  460 00AF              ZDIV       EQU      0AFH        ; /
  461 00B2              ZOR        EQU      0B2H        ; OR
  462 00B3              ZGTR       EQU      0B3H        ; >
  463 00B4              ZEQUAL     EQU      0B4H        ; M
  464 00B5              ZLTH       EQU      0B5H        ; <
  465 00B6              ZSGN       EQU      0B6H        ; SGN
  466 00C7              ZPOINT     EQU      0C7H        ; POINT
  467 00CF              ZLEFT      EQU      0CDH +2     ; LEFT$
  468                   ;
  469                   ; ARITHMETIC PRECEDENCE TABLE
  470                   ;
  471 02EA 79           PRITAB:    DB       79H         ; Precedence value
  472 02EB 2018                    DW       PADD        ; FPREG = <last> + FPRE
  473                   ;
  474 02ED 79                      DB       79H         ; Precedence value
  475 02EE 5414                    DW       PSUB        ; FPREG = <last> - FPRE
  476                   ;
  477 02F0 7C                      DB       7CH         ; Precedence value
  478 02F1 9215                    DW       MULT        ; PPREG = <last> * FPRE
  479                   ;
  480 02F3 7C                      DB       7CH         ; Precedence value
  481 02F4 F315                    DW       DIV         ; FPREG = <last> / FPRE
  482                   ;
  483 02F6 7F                      DB       7FH         ; Precedence value
  484 02F7 4119                    DW       POWER       ; FPREG = <last> ^ FPRE
  485                   ;
  486 02F9 50                      DB       50H         ; Precedence value
  487 02FA 070E                    DW       PAND        ; FPREG = <last> AND FP
  488                   ;
  489 02FC 46                      DB       46H         ; Precedence value
  490 02FD 060E                    DW       POR         ; FPREG = <last> OR FPR
  491                   ;
  492                   ; BASIC ERROR CODE LIST
  493                   ;
  494 02FF 4E46         ERRORS:    DB       "NF"        ; NEXT without FOR
  495 0301 534E                    DB       "SN"        ; Syntax error
  496 0303 5247                    DB       "RG"        ; RETURN without GOSUB
  497 0305 4F44                    DB       "OD"        ; Out of DATA
  498 0307 4643                    DB       "FC"        ; Illegal function call
  499 0309 4F56                    DB       "OV"        ; Overflow error
  500 030B 4F4D                    DB       "OM"        ; Out of memory
  501 030D 554C                    DB       "UL"        ; Undefined line
  502 030F 4253                    DB       "BS"        ; Bad subscript
  503 0311 4444                    DB       "DD"        ; Re-DIMensioned array
  504 0313 2F30                    DB       "/0"        ; Division by zero
  505 0315 4944                    DB       "ID"        ; Illegal direct
  506 0317 544D                    DB       "TM"        ; Type mis-match
  507 0319 4F53                    DB       "OS"        ; Out of string space
  508 031B 4C53                    DB       "LS"        ; String too long
  509 031D 5354                    DB       "ST"        ; String formula too co
  510 031F 434E                    DB       "CN"        ; Can't CONTinue
  511 0321 5546                    DB       "UF"        ; Undefined FN function
  512 0323 4D4F                    DB       "MO"        ; Missing operand
  513 0325 4858                    DB       "HX"        ; HEX error
  514 0327 424E                    DB       "BN"        ; BIN error
  515                   ;
  516                   ; INITIALISATION TABLE --------------------------------
  517                   ;
  518 0329 C3BF00       INITAB:    JP       WARMST      ; Warm start jump
  519 032C C31709                  JP       FCERR       ; "USR (X)" jump (Set t
  520 032F D300                    OUT      (0),A       ; "OUT p,n" skeleton
  521 0331 C9                      RET
  522 0332 D600                    SUB      0           ; Division support rout
  523 0334 6F                      LD       L,A
  524 0335 7C                      LD       A,H
  525 0336 DE00                    SBC      A,0
  526 0338 67                      LD       H,A
  527 0339 78                      LD       A,B
  528 033A DE00                    SBC      A,0
  529 033C 47                      LD       B,A
  530 033D 3E00                    LD       A,0
  531 033F C9                      RET
  532 0340 000000                  DB       0,0,0       ; Random number seed ta
  533 0343 354ACA99                DB       035H,04AH,0CAH,099H ;-2.65145E+07
  534 0347 391C7698                DB       039H,01CH,076H,098H ; 1.61291E+07
  535 034B 2295B398                DB       022H,095H,0B3H,098H ;-1.17691E+07
  536 034F 0ADD4798                DB       00AH,0DDH,047H,098H ; 1.30983E+07
  537 0353 53D19999                DB       053H,0D1H,099H,099H ;-2-01612E+07
  538 0357 0A1A9F98                DB       00AH,01AH,09FH,098H ;-1.04269E+07
  539 035B 65BCCD98                DB       065H,0BCH,0CDH,098H ;-1.34831E+07
  540 035F D6773E98                DB       0D6H,077H,03EH,098H ; 1.24825E+07
  541 0363 52C74F80                DB       052H,0C7H,04FH,080H ; Last random n
  542 0367 DB00                    IN       A,(0)       ; INP (x) skeleton
  543 0369 C9                      RET
  544 036A 01                      DB       1           ; POS (x) number (1)
  545 036B FF                      DB       255         ; Terminal width (255 =
  546 036C 1C                      DB       28          ; Width for commas (3 c
  547 036D 00                      DB       0           ; No nulls after input 
  548 036E 00                      DB       0           ; Output enabled (^O of
  549 036F 1400                    DW       20          ; Initial lines counter
  550 0371 1400                    DW       20          ; Initial lines number
  551 0373 0000                    DW       0           ; Array load/save check
  552 0375 00                      DB       0           ; Break not by NMI
  553 0376 00                      DB       0           ; Break flag
  554 0377 C33D06                  JP       TTYLIN      ; Input reflection (set
  555 037A C30000                  JP       0000H       ; POINT reflection unus
  556 037D C30000                  JP       0000H       ; SET reflection
  557 0380 C30000                  JP       0000H       ; RESET reflection
  558 0383 A281                    DW       STLOOK      ; Temp string space
  559 0385 FEFF                    DW       -2          ; Current line number (
  560 0387 3F81                    DW       PROGST+1    ; Start of program text
  561 0389              INITBE:
  562                   ;
  563                   ; END OF INITIALISATION TABLE -------------------------
  564                   ;
  565 0389 204572726F72 ERRMSG:    DB       " Error",0
           00           
  566 0390 20696E2000   INMSG:     DB       " in ",0
  567 0394              ZERBYT     EQU      $-1         ; A zero byte
  568 0395 4F6B0D0A0000 OKMSG:     DB       "Ok",CR,LF,0,0
  569 039B 427265616B00 BRKMSG:    DB       "Break",0
  570                   ;
  571 03A1 210400       BAKSTK:    LD       HL,4        ; Look for "FOR" block 
  572 03A4 39                      ADD      HL,SP       ; same index as specifi
  573 03A5 7E           LOKFOR:    LD       A,(HL)      ; Get block ID
  574 03A6 23                      INC      HL          ; Point to index addres
  575 03A7 FE81                    CP       ZFOR        ; Is it a "FOR" token
  576 03A9 C0                      RET      NZ          ; No - exit
  577 03AA 4E                      LD       C,(HL)      ; BC = Address of "FOR"
  578 03AB 23                      INC      HL
  579 03AC 46                      LD       B,(HL)
  580 03AD 23                      INC      HL          ; Point to sign of STEP
  581 03AE E5                      PUSH     HL          ; Save pointer to sign
  582 03AF 69                      LD       L,C         ; HL = address of "FOR"
  583 03B0 60                      LD       H,B
  584 03B1 7A                      LD       A,D         ; See if an index was s
  585 03B2 B3                      OR       E           ; DE = 0 if no index sp
  586 03B3 EB                      EX       DE,HL       ; Specified index into 
  587 03B4 CABB03                  JP       Z,INDFND    ; Skip if no index give
  588 03B7 EB                      EX       DE,HL       ; Index back into DE
  589 03B8 CDC006                  CALL     CPDEHL      ; Compare index with on
  590 03BB 010D00       INDFND:    LD       BC,16-3     ; Offset to next block
  591 03BE E1                      POP      HL          ; Restore pointer to si
  592 03BF C8                      RET      Z           ; Return if block found
  593 03C0 09                      ADD      HL,BC       ; Point to next block
  594 03C1 C3A503                  JP       LOKFOR      ; Keep on looking
  595                   ;
  596 03C4 CDDE03       MOVUP:     CALL     ENFMEM      ; See if enough memory
  597 03C7 C5           MOVSTR:    PUSH     BC          ; Save end of source
  598 03C8 E3                      EX       (SP),HL     ; Swap source and dest"
  599 03C9 C1                      POP      BC          ; Get end of destinatio
  600 03CA CDC006       MOVLP:     CALL     CPDEHL      ; See if list moved
  601 03CD 7E                      LD       A,(HL)      ; Get byte
  602 03CE 02                      LD       (BC),A      ; Move it
  603 03CF C8                      RET      Z           ; Exit if all done
  604 03D0 0B                      DEC      BC          ; Next byte to move to
  605 03D1 2B                      DEC      HL          ; Next byte to move
  606 03D2 C3CA03                  JP       MOVLP       ; Loop until all bytes 
  607                   ;
  608 03D5 E5           CHKSTK:    PUSH     HL          ; Save code string addr
  609 03D6 2A1F81                  LD       HL,(ARREND) ; Lowest free memory
  610 03D9 0600                    LD       B,0         ; BC = Number of levels
  611 03DB 09                      ADD      HL,BC       ; 2 Bytes for each leve
  612 03DC 09                      ADD      HL,BC
  613 03DD 3E                      DB       3EH         ; Skip "PUSH HL"
  614 03DE E5           ENFMEM:    PUSH     HL          ; Save code string addr
  615 03DF 3ED0                    LD       A,0D0H      ; LOW -48; 48 Bytes min
  616 03E1 95                      SUB      L
  617 03E2 6F                      LD       L,A
  618 03E3 3EFF                    LD       A,0FFH      ; HIGH (-48); 48 Bytes 
  619 03E5 9C                      SBC      A,H
  620 03E6 DAED03                  JP       C,OMERR     ; Not enough - ?OM Erro
  621 03E9 67                      LD       H,A
  622 03EA 39                      ADD      HL,SP       ; Test if stack is over
  623 03EB E1                      POP      HL          ; Restore code string a
  624 03EC D8                      RET      C           ; Return if enough mmor
  625 03ED 1E0C         OMERR:     LD       E,OM        ; ?OM Error
  626 03EF C30C04                  JP       ERROR
  627                   ;
  628 03F2 2A0E81       DATSNR:    LD       HL,(DATLIN) ; Get line of current D
  629 03F5 22A180                  LD       (LINEAT),HL ; Save as current line
  630 03F8 1E02         SNERR:     LD       E,SN        ; ?SN Error
  631 03FA 01                      DB       01H         ; Skip "LD E,DZ"
  632 03FB 1E14         DZERR:     LD       E,DZ        ; ?/0 Error
  633 03FD 01                      DB       01H         ; Skip "LD E,NF"
  634 03FE 1E00         NFERR:     LD       E,NF        ; ?NF Error
  635 0400 01                      DB       01H         ; Skip "LD E,RD"
  636 0401 1E12         DDERR:     LD       E,RD        ; ?DD Error
  637 0403 01                      DB       01H         ; Skip "LD E,UF"
  638 0404 1E22         UFERR:     LD       E,UF        ; ?UF Error
  639 0406 01                      DB       01H         ; Skip "LD E,OV
  640 0407 1E0A         OVERR:     LD       E,OV        ; ?OV Error
  641 0409 01                      DB       01H         ; Skip "LD E,TM"
  642 040A 1E18         TMERR:     LD       E,TM        ; ?TM Error
  643                   ;
  644 040C CD2A05       ERROR:     CALL     CLREG       ; Clear registers and s
  645 040F 328A80                  LD       (CTLOFG),A  ; Enable output (A is 0
  646 0412 CDEB0A                  CALL     STTLIN      ; Start new line
  647 0415 21FF02                  LD       HL,ERRORS   ; Point to error codes
  648 0418 57                      LD       D,A         ; D = 0 (A is 0)
  649 0419 3E3F                    LD       A,'?'
  650 041B CDD106                  CALL     OUTC        ; Output '?'
  651 041E 19                      ADD      HL,DE       ; Offset to correct err
  652 041F 7E                      LD       A,(HL)      ; First character
  653 0420 CDD106                  CALL     OUTC        ; Output it
  654 0423 CD5008                  CALL     GETCHR      ; Get next character
  655 0426 CDD106                  CALL     OUTC        ; Output it
  656 0429 218903                  LD       HL,ERRMSG   ; "Error" message
  657 042C CD9611       ERRIN:     CALL     PRS         ; Output message
  658 042F 2AA180                  LD       HL,(LINEAT) ; Get line of error
  659 0432 11FEFF                  LD       DE,-2       ; Cold start error if -
  660 0435 CDC006                  CALL     CPDEHL      ; See if cold start err
  661 0438 CA5100                  JP       Z,CSTART    ; Cold start error - Re
  662 043B 7C                      LD       A,H         ; Was it a direct error
  663 043C A5                      AND      L           ; Line = -1 if direct e
  664 043D 3C                      INC      A
  665 043E C43118                  CALL     NZ,LINEIN   ; No - output line of e
  666 0441 3E                      DB       3EH         ; Skip "POP BC"
  667 0442 C1           POPNOK:    POP      BC          ; Drop address in input
  668                   ;
  669 0443 AF           PRNTOK:    XOR      A           ; Output "Ok" and get c
  670 0444 328A80                  LD       (CTLOFG),A  ; Enable output
  671 0447 CDEB0A                  CALL     STTLIN      ; Start new line
  672 044A 219503                  LD       HL,OKMSG    ; "Ok" message
  673 044D CD9611                  CALL     PRS         ; Output "Ok"
  674 0450 21FFFF       GETCMD:    LD       HL,-1       ; Flag direct mode
  675 0453 22A180                  LD       (LINEAT),HL ; Save as current line
  676 0456 CD3D06                  CALL     GETLIN      ; Get an input line
  677 0459 DA5004                  JP       C,GETCMD    ; Get line again if bre
  678 045C CD5008                  CALL     GETCHR      ; Get first character
  679 045F 3C                      INC      A           ; Test if end of line
  680 0460 3D                      DEC      A           ; Without affecting Car
  681 0461 CA5004                  JP       Z,GETCMD    ; Nothing entered - Get
  682 0464 F5                      PUSH     AF          ; Save Carry status
  683 0465 CD1C09                  CALL     ATOH        ; Get line number into 
  684 0468 D5                      PUSH     DE          ; Save line number
  685 0469 CD5405                  CALL     CRUNCH      ; Tokenise rest of line
  686 046C 47                      LD       B,A         ; Length of tokenised l
  687 046D D1                      POP      DE          ; Restore line number
  688 046E F1                      POP      AF          ; Restore Carry
  689 046F D23008                  JP       NC,EXCUTE   ; No line number - Dire
  690 0472 D5                      PUSH     DE          ; Save line number
  691 0473 C5                      PUSH     BC          ; Save length of tokeni
  692 0474 AF                      XOR      A
  693 0475 321181                  LD       (LSTBIN),A  ; Clear last byte input
  694 0478 CD5008                  CALL     GETCHR      ; Get next character
  695 047B B7                      OR       A           ; Set flags
  696 047C F5                      PUSH     AF          ; And save them
  697 047D CDE404                  CALL     SRCHLN      ; Search for line numbe
  698 0480 DA8904                  JP       C,LINFND    ; Jump if line found
  699 0483 F1                      POP      AF          ; Get status
  700 0484 F5                      PUSH     AF          ; And re-save
  701 0485 CABD09                  JP       Z,ULERR     ; Nothing after number 
  702 0488 B7                      OR       A           ; Clear Carry
  703 0489 C5           LINFND:    PUSH     BC          ; Save address of line 
  704 048A D2A004                  JP       NC,INEWLN   ; Line not found - Inse
  705 048D EB                      EX       DE,HL       ; Next line address in 
  706 048E 2A1B81                  LD       HL,(PROGND) ; End of program
  707 0491 1A           SFTPRG:    LD       A,(DE)      ; Shift rest of program
  708 0492 02                      LD       (BC),A
  709 0493 03                      INC      BC          ; Next destination
  710 0494 13                      INC      DE          ; Next source
  711 0495 CDC006                  CALL     CPDEHL      ; All done?
  712 0498 C29104                  JP       NZ,SFTPRG   ; More to do
  713 049B 60                      LD       H,B         ; HL - New end of progr
  714 049C 69                      LD       L,C
  715 049D 221B81                  LD       (PROGND),HL ; Update end of program
  716                   ;
  717 04A0 D1           INEWLN:    POP      DE          ; Get address of line,
  718 04A1 F1                      POP      AF          ; Get status
  719 04A2 CAC704                  JP       Z,SETPTR    ; No text - Set up poin
  720 04A5 2A1B81                  LD       HL,(PROGND) ; Get end of program
  721 04A8 E3                      EX       (SP),HL     ; Get length of input l
  722 04A9 C1                      POP      BC          ; End of program to BC
  723 04AA 09                      ADD      HL,BC       ; Find new end
  724 04AB E5                      PUSH     HL          ; Save new end
  725 04AC CDC403                  CALL     MOVUP       ; Make space for line
  726 04AF E1                      POP      HL          ; Restore new end
  727 04B0 221B81                  LD       (PROGND),HL ; Update end of program
  728 04B3 EB                      EX       DE,HL       ; Get line to move up i
  729 04B4 74                      LD       (HL),H      ; Save MSB
  730 04B5 D1                      POP      DE          ; Get new line number
  731 04B6 23                      INC      HL          ; Skip pointer
  732 04B7 23                      INC      HL
  733 04B8 73                      LD       (HL),E      ; Save LSB of line numb
  734 04B9 23                      INC      HL
  735 04BA 72                      LD       (HL),D      ; Save MSB of line numb
  736 04BB 23                      INC      HL          ; To first byte in line
  737 04BC 11A680                  LD       DE,BUFFER   ; Copy buffer to progra
  738 04BF 1A           MOVBUF:    LD       A,(DE)      ; Get source
  739 04C0 77                      LD       (HL),A      ; Save destinations
  740 04C1 23                      INC      HL          ; Next source
  741 04C2 13                      INC      DE          ; Next destination
  742 04C3 B7                      OR       A           ; Done?
  743 04C4 C2BF04                  JP       NZ,MOVBUF   ; No - Repeat
  744 04C7 CD1005       SETPTR:    CALL     RUNFST      ; Set line pointers
  745 04CA 23                      INC      HL          ; To LSB of pointer
  746 04CB EB                      EX       DE,HL       ; Address to DE
  747 04CC 62           PTRLP:     LD       H,D         ; Address to HL
  748 04CD 6B                      LD       L,E
  749 04CE 7E                      LD       A,(HL)      ; Get LSB of pointer
  750 04CF 23                      INC      HL          ; To MSB of pointer
  751 04D0 B6                      OR       (HL)        ; Compare with MSB poin
  752 04D1 CA5004                  JP       Z,GETCMD    ; Get command line if e
  753 04D4 23                      INC      HL          ; To LSB of line number
  754 04D5 23                      INC      HL          ; Skip line number
  755 04D6 23                      INC      HL          ; Point to first byte i
  756 04D7 AF                      XOR      A           ; Looking for 00 byte
  757 04D8 BE           FNDEND:    CP       (HL)        ; Found end of line?
  758 04D9 23                      INC      HL          ; Move to next byte
  759 04DA C2D804                  JP       NZ,FNDEND   ; No - Keep looking
  760 04DD EB                      EX       DE,HL       ; Next line address to 
  761 04DE 73                      LD       (HL),E      ; Save LSB of pointer
  762 04DF 23                      INC      HL
  763 04E0 72                      LD       (HL),D      ; Save MSB of pointer
  764 04E1 C3CC04                  JP       PTRLP       ; Do next line
  765                   ;
  766 04E4 2AA380       SRCHLN:    LD       HL,(BASTXT) ; Start of program text
  767 04E7 44           SRCHLP:    LD       B,H         ; BC = Address to look 
  768 04E8 4D                      LD       C,L
  769 04E9 7E                      LD       A,(HL)      ; Get address of next l
  770 04EA 23                      INC      HL
  771 04EB B6                      OR       (HL)        ; End of program found?
  772 04EC 2B                      DEC      HL
  773 04ED C8                      RET      Z           ; Yes - Line not found
  774 04EE 23                      INC      HL
  775 04EF 23                      INC      HL
  776 04F0 7E                      LD       A,(HL)      ; Get LSB of line numbe
  777 04F1 23                      INC      HL
  778 04F2 66                      LD       H,(HL)      ; Get MSB of line numbe
  779 04F3 6F                      LD       L,A
  780 04F4 CDC006                  CALL     CPDEHL      ; Compare with line in 
  781 04F7 60                      LD       H,B         ; HL = Start of this li
  782 04F8 69                      LD       L,C
  783 04F9 7E                      LD       A,(HL)      ; Get LSB of next line 
  784 04FA 23                      INC      HL
  785 04FB 66                      LD       H,(HL)      ; Get MSB of next line 
  786 04FC 6F                      LD       L,A         ; Next line to HL
  787 04FD 3F                      CCF
  788 04FE C8                      RET      Z           ; Lines found - Exit
  789 04FF 3F                      CCF
  790 0500 D0                      RET      NC          ; Line not found,at lin
  791 0501 C3E704                  JP       SRCHLP      ; Keep looking
  792                   ;
  793 0504 C0           NEW:       RET      NZ          ; Return if any more on
  794 0505 2AA380       CLRPTR:    LD       HL,(BASTXT) ; Point to start of pro
  795 0508 AF                      XOR      A           ; Set program area to e
  796 0509 77                      LD       (HL),A      ; Save LSB = 00
  797 050A 23                      INC      HL
  798 050B 77                      LD       (HL),A      ; Save MSB = 00
  799 050C 23                      INC      HL
  800 050D 221B81                  LD       (PROGND),HL ; Set program end
  801                   ;
  802 0510 2AA380       RUNFST:    LD       HL,(BASTXT) ; Clear all variables
  803 0513 2B                      DEC      HL
  804                   ;
  805 0514 221381       INTVAR:    LD       (BRKLIN),HL ; Initialise RUN variab
  806 0517 2AF480                  LD       HL,(LSTRAM) ; Get end of RAM
  807 051A 220881                  LD       (STRBOT),HL ; Clear string space
  808 051D AF                      XOR      A
  809 051E CD6008                  CALL     RESTOR      ; Reset DATA pointers
  810 0521 2A1B81                  LD       HL,(PROGND) ; Get end of program
  811 0524 221D81                  LD       (VAREND),HL ; Clear variables
  812 0527 221F81                  LD       (ARREND),HL ; Clear arrays
  813                   ;
  814 052A C1           CLREG:     POP      BC          ; Save return address
  815 052B 2A9F80                  LD       HL,(STRSPC) ; Get end of working RA
  816 052E F9                      LD       SP,HL       ; Set stack
  817 052F 21F880                  LD       HL,TMSTPL   ; Temporary string pool
  818 0532 22F680                  LD       (TMSTPT),HL ; Reset temporary strin
  819 0535 AF                      XOR      A           ; A = 00
  820 0536 6F                      LD       L,A         ; HL = 0000
  821 0537 67                      LD       H,A
  822 0538 221981                  LD       (CONTAD),HL ; No CONTinue
  823 053B 321081                  LD       (FORFLG),A  ; Clear FOR flag
  824 053E 222381                  LD       (FNRGNM),HL ; Clear FN argument
  825 0541 E5                      PUSH     HL          ; HL = 0000
  826 0542 C5                      PUSH     BC          ; Put back return
  827 0543 2A1381       DOAGN:     LD       HL,(BRKLIN) ; Get address of code t
  828 0546 C9                      RET                  ; Return to execution d
  829                   ;
  830 0547 3E3F         PROMPT:    LD       A,'?'       ; '?'
  831 0549 CDD106                  CALL     OUTC        ; Output character
  832 054C 3E20                    LD       A,' '       ; Space
  833 054E CDD106                  CALL     OUTC        ; Output character
  834 0551 C39380                  JP       RINPUT      ; Get input line
  835                   ;
  836 0554 AF           CRUNCH:    XOR      A           ; Tokenise line @ HL to
  837 0555 32F380                  LD       (DATFLG),A  ; Reset literal flag
  838 0558 0E05                    LD       C,2+3       ; 2 byte number and 3 n
  839 055A 11A680                  LD       DE,BUFFER   ; Start of input buffer
  840 055D 7E           CRNCLP:    LD       A,(HL)      ; Get byte
  841 055E FE20                    CP       ' '         ; Is it a space?
  842 0560 CADC05                  JP       Z,MOVDIR    ; Yes - Copy direct
  843 0563 47                      LD       B,A         ; Save character
  844 0564 FE22                    CP       '"'         ; Is it a quote?
  845 0566 CAFC05                  JP       Z,CPYLIT    ; Yes - Copy literal st
  846 0569 B7                      OR       A           ; Is it end of buffer?
  847 056A CA0306                  JP       Z,ENDBUF    ; Yes - End buffer
  848 056D 3AF380                  LD       A,(DATFLG)  ; Get data type
  849 0570 B7                      OR       A           ; Literal?
  850 0571 7E                      LD       A,(HL)      ; Get byte to copy
  851 0572 C2DC05                  JP       NZ,MOVDIR   ; Literal - Copy direct
  852 0575 FE3F                    CP       '?'         ; Is it '?' short for P
  853 0577 3E9E                    LD       A,ZPRINT    ; "PRINT" token
  854 0579 CADC05                  JP       Z,MOVDIR    ; Yes - replace it
  855 057C 7E                      LD       A,(HL)      ; Get byte again
  856 057D FE30                    CP       '0'         ; Is it less than '0'
  857 057F DA8705                  JP       C,FNDWRD    ; Yes - Look for reserv
  858 0582 FE3C                    CP       60          ; ";"+1; Is it "0123456
  859 0584 DADC05                  JP       C,MOVDIR    ; Yes - copy it direct
  860 0587 D5           FNDWRD:    PUSH     DE          ; Look for reserved wor
  861 0588 118001                  LD       DE,WORDS-1  ; Point to table
  862 058B C5                      PUSH     BC          ; Save count
  863 058C 01D805                  LD       BC,RETNAD   ; Where to return to
  864 058F C5                      PUSH     BC          ; Save return address
  865 0590 067F                    LD       B,ZEND-1    ; First token value -1
  866 0592 7E                      LD       A,(HL)      ; Get byte
  867 0593 FE61                    CP       'a'         ; Less than 'a' ?
  868 0595 DAA005                  JP       C,SEARCH    ; Yes - search for word
  869 0598 FE7B                    CP       'z'+1       ; Greater than 'z' ?
  870 059A D2A005                  JP       NC,SEARCH   ; Yes - search for word
  871 059D E65F                    AND      01011111B   ; Force upper case
  872 059F 77                      LD       (HL),A      ; Replace byte
  873 05A0 4E           SEARCH:    LD       C,(HL)      ; Search for a word
  874 05A1 EB                      EX       DE,HL
  875 05A2 23           GETNXT:    INC      HL          ; Get next reserved wor
  876 05A3 B6                      OR       (HL)        ; Start of word?
  877 05A4 F2A205                  JP       P,GETNXT    ; No - move on
  878 05A7 04                      INC      B           ; Increment token value
  879 05A8 7E                      LD       A, (HL)     ; Get byte from table
  880 05A9 E67F                    AND      01111111B   ; Strip bit 7
  881 05AB C8                      RET      Z           ; Return if end of list
  882 05AC B9                      CP       C           ; Same character as in 
  883 05AD C2A205                  JP       NZ,GETNXT   ; No - get next word
  884 05B0 EB                      EX       DE,HL
  885 05B1 E5                      PUSH     HL          ; Save start of word
  886                   ;
  887 05B2 13           NXTBYT:    INC      DE          ; Look through rest of 
  888 05B3 1A                      LD       A,(DE)      ; Get byte from table
  889 05B4 B7                      OR       A           ; End of word ?
  890 05B5 FAD405                  JP       M,MATCH     ; Yes - Match found
  891 05B8 4F                      LD       C,A         ; Save it
  892 05B9 78                      LD       A,B         ; Get token value
  893 05BA FE88                    CP       ZGOTO       ; Is it "GOTO" token ?
  894 05BC C2C305                  JP       NZ,NOSPC    ; No - Don't allow spac
  895 05BF CD5008                  CALL     GETCHR      ; Get next character
  896 05C2 2B                      DEC      HL          ; Cancel increment from
  897 05C3 23           NOSPC:     INC      HL          ; Next byte
  898 05C4 7E                      LD       A,(HL)      ; Get byte
  899 05C5 FE61                    CP       'a'         ; Less than 'a' ?
  900 05C7 DACC05                  JP       C,NOCHNG    ; Yes - don't change
  901 05CA E65F                    AND      01011111B   ; Make upper case
  902 05CC B9           NOCHNG:    CP       C           ; Same as in buffer ?
  903 05CD CAB205                  JP       Z,NXTBYT    ; Yes - keep testing
  904 05D0 E1                      POP      HL          ; Get back start of wor
  905 05D1 C3A005                  JP       SEARCH      ; Look at next word
  906                   ;
  907 05D4 48           MATCH:     LD       C,B         ; Word found - Save tok
  908 05D5 F1                      POP      AF          ; Throw away return
  909 05D6 EB                      EX       DE,HL
  910 05D7 C9                      RET                  ; Return to "RETNAD"
  911 05D8 EB           RETNAD:    EX       DE,HL       ; Get address in string
  912 05D9 79                      LD       A,C         ; Get token value
  913 05DA C1                      POP      BC          ; Restore buffer length
  914 05DB D1                      POP      DE          ; Get destination addre
  915 05DC 23           MOVDIR:    INC      HL          ; Next source in buffer
  916 05DD 12                      LD       (DE),A      ; Put byte in buffer
  917 05DE 13                      INC      DE          ; Move up buffer
  918 05DF 0C                      INC      C           ; Increment length of b
  919 05E0 D63A                    SUB      ':'         ; End of statement?
  920 05E2 CAEA05                  JP       Z,SETLIT    ; Jump if multi-stateme
  921 05E5 FE49                    CP       ZDATA-3AH   ; Is it DATA statement 
  922 05E7 C2ED05                  JP       NZ,TSTREM   ; No - see if REM
  923 05EA 32F380       SETLIT:    LD       (DATFLG),A  ; Set literal flag
  924 05ED D654         TSTREM:    SUB      ZREM-3AH    ; Is it REM?
  925 05EF C25D05                  JP       NZ,CRNCLP   ; No - Leave flag
  926 05F2 47                      LD       B,A         ; Copy rest of buffer
  927 05F3 7E           NXTCHR:    LD       A,(HL)      ; Get byte
  928 05F4 B7                      OR       A           ; End of line ?
  929 05F5 CA0306                  JP       Z,ENDBUF    ; Yes - Terminate buffe
  930 05F8 B8                      CP       B           ; End of statement ?
  931 05F9 CADC05                  JP       Z,MOVDIR    ; Yes - Get next one
  932 05FC 23           CPYLIT:    INC      HL          ; Move up source string
  933 05FD 12                      LD       (DE),A      ; Save in destination
  934 05FE 0C                      INC      C           ; Increment length
  935 05FF 13                      INC      DE          ; Move up destination
  936 0600 C3F305                  JP       NXTCHR      ; Repeat
  937                   ;
  938 0603 21A580       ENDBUF:    LD       HL,BUFFER-1 ; Point to start of buf
  939 0606 12                      LD       (DE),A      ; Mark end of buffer (A
  940 0607 13                      INC      DE
  941 0608 12                      LD       (DE),A      ; A = 00
  942 0609 13                      INC      DE
  943 060A 12                      LD       (DE),A      ; A = 00
  944 060B C9                      RET
  945                   ;
  946 060C 3A8980       DODEL:     LD       A,(NULFLG)  ; Get null flag status
  947 060F B7                      OR       A           ; Is it zero?
  948 0610 3E00                    LD       A,0         ; Zero A - Leave flags
  949 0612 328980                  LD       (NULFLG),A  ; Zero null flag
  950 0615 C22006                  JP       NZ,ECHDEL   ; Set - Echo it
  951 0618 05                      DEC      B           ; Decrement length
  952 0619 CA3D06                  JP       Z,GETLIN    ; Get line again if emp
  953 061C CDD106                  CALL     OUTC        ; Output null character
  954 061F 3E                      DB       3EH         ; Skip "DEC B"
  955 0620 05           ECHDEL:    DEC      B           ; Count bytes in buffer
  956 0621 2B                      DEC      HL          ; Back space buffer
  957 0622 CA3406                  JP       Z,OTKLN     ; No buffer - Try again
  958 0625 7E                      LD       A,(HL)      ; Get deleted byte
  959 0626 CDD106                  CALL     OUTC        ; Echo it
  960 0629 C34606                  JP       MORINP      ; Get more input
  961                   ;
  962 062C 05           DELCHR:    DEC      B           ; Count bytes in buffer
  963 062D 2B                      DEC      HL          ; Back space buffer
  964 062E CDD106                  CALL     OUTC        ; Output character in A
  965 0631 C24606                  JP       NZ,MORINP   ; Not end - Get more
  966 0634 CDD106       OTKLN:     CALL     OUTC        ; Output character in A
  967 0637 CDF80A       KILIN:     CALL     PRCRLF      ; Output CRLF
  968 063A C33D06                  JP       TTYLIN      ; Get line again
  969                   ;
  970 063D              GETLIN:
  971 063D 21A680       TTYLIN:    LD       HL,BUFFER   ; Get a line by charact
  972 0640 0601                    LD       B,1         ; Set buffer as empty
  973 0642 AF                      XOR      A
  974 0643 328980                  LD       (NULFLG),A  ; Clear null flag
  975 0646 CDFB06       MORINP:    CALL     CLOTST      ; Get character and tes
  976 0649 4F                      LD       C,A         ; Save character in C
  977 064A FE7F                    CP       DEL         ; Delete character?
  978 064C CA0C06                  JP       Z,DODEL     ; Yes - Process it
  979 064F 3A8980                  LD       A,(NULFLG)  ; Get null flag
  980 0652 B7                      OR       A           ; Test null flag status
  981 0653 CA5F06                  JP       Z,PROCES    ; Reset - Process chara
  982 0656 3E00                    LD       A,0         ; Set a null
  983 0658 CDD106                  CALL     OUTC        ; Output null
  984 065B AF                      XOR      A           ; Clear A
  985 065C 328980                  LD       (NULFLG),A  ; Reset null flag
  986 065F 79           PROCES:    LD       A,C         ; Get character
  987 0660 FE07                    CP       CTRLG       ; Bell?
  988 0662 CAA306                  JP       Z,PUTCTL    ; Yes - Save it
  989 0665 FE03                    CP       CTRLC       ; Is it control "C"?
  990 0667 CCF80A                  CALL     Z,PRCRLF    ; Yes - Output CRLF
  991 066A 37                      SCF                  ; Flag break
  992 066B C8                      RET      Z           ; Return if control "C"
  993 066C FE0D                    CP       CR          ; Is it enter?
  994 066E CAF30A                  JP       Z,ENDINP    ; Yes - Terminate input
  995 0671 FE15                    CP       CTRLU       ; Is it control "U"?
  996 0673 CA3706                  JP       Z,KILIN     ; Yes - Get another lin
  997 0676 FE40                    CP       '@'         ; Is it "kill line"?
  998 0678 CA3406                  JP       Z,OTKLN     ; Yes - Kill line
  999 067B FE5F                    CP       '_'         ; Is it delete?
 1000 067D CA2C06                  JP       Z,DELCHR    ; Yes - Delete characte
 1001 0680 FE08                    CP       BKSP        ; Is it backspace?
 1002 0682 CA2C06                  JP       Z,DELCHR    ; Yes - Delete characte
 1003 0685 FE12                    CP       CTRLR       ; Is it control "R"?
 1004 0687 C29E06                  JP       NZ,PUTBUF   ; No - Put in buffer
 1005 068A C5                      PUSH     BC          ; Save buffer length
 1006 068B D5                      PUSH     DE          ; Save DE
 1007 068C E5                      PUSH     HL          ; Save buffer address
 1008 068D 3600                    LD       (HL),0      ; Mark end of buffer
 1009 068F CDA21C                  CALL     OUTNCR      ; Output and do CRLF
 1010 0692 21A680                  LD       HL,BUFFER   ; Point to buffer start
 1011 0695 CD9611                  CALL     PRS         ; Output buffer
 1012 0698 E1                      POP      HL          ; Restore buffer addres
 1013 0699 D1                      POP      DE          ; Restore DE
 1014 069A C1                      POP      BC          ; Restore buffer length
 1015 069B C34606                  JP       MORINP      ; Get another character
 1016                   ;
 1017 069E FE20         PUTBUF:    CP       ' '         ; Is it a control code?
 1018 06A0 DA4606                  JP       C,MORINP    ; Yes - Ignore
 1019 06A3 78           PUTCTL:    LD       A,B         ; Get number of bytes i
 1020 06A4 FE49                    CP       72+1        ; Test for line overflo
 1021 06A6 3E07                    LD       A,CTRLG     ; Set a bell
 1022 06A8 D2B806                  JP       NC,OUTNBS   ; Ring bell if buffer f
 1023 06AB 79                      LD       A,C         ; Get character
 1024 06AC 71                      LD       (HL),C      ; Save in buffer
 1025 06AD 321181                  LD       (LSTBIN),A  ; Save last input byte
 1026 06B0 23                      INC      HL          ; Move up buffer
 1027 06B1 04                      INC      B           ; Increment length
 1028 06B2 CDD106       OUTIT:     CALL     OUTC        ; Output the character 
 1029 06B5 C34606                  JP       MORINP      ; Get another character
 1030                   ;
 1031 06B8 CDD106       OUTNBS:    CALL     OUTC        ; Output bell and back 
 1032 06BB 3E08                    LD       A,BKSP      ; Set back space
 1033 06BD C3B206                  JP       OUTIT       ; Output it and get mor
 1034                   ;
 1035 06C0 7C           CPDEHL:    LD       A,H         ; Get H
 1036 06C1 92                      SUB      D           ; Compare with D
 1037 06C2 C0                      RET      NZ          ; Different - Exit
 1038 06C3 7D                      LD       A,L         ; Get L
 1039 06C4 93                      SUB      E           ; Compare with E
 1040 06C5 C9                      RET                  ; Return status
 1041                   ;
 1042 06C6 7E           CHKSYN:    LD       A,(HL)      ; Check syntax of chara
 1043 06C7 E3                      EX       (SP),HL     ; Address of test byte
 1044 06C8 BE                      CP       (HL)        ; Same as in code strin
 1045 06C9 23                      INC      HL          ; Return address
 1046 06CA E3                      EX       (SP),HL     ; Put it back
 1047 06CB CA5008                  JP       Z,GETCHR    ; Yes - Get next charac
 1048 06CE C3F803                  JP       SNERR       ; Different - ?SN Error
 1049                   ;
 1050 06D1 F5           OUTC:      PUSH     AF          ; Save character
 1051 06D2 3A8A80                  LD       A,(CTLOFG)  ; Get control "O" flag
 1052 06D5 B7                      OR       A           ; Is it set?
 1053 06D6 C2CB11                  JP       NZ,POPAF    ; Yes - don't output
 1054 06D9 F1                      POP      AF          ; Restore character
 1055 06DA C5                      PUSH     BC          ; Save buffer length
 1056 06DB F5                      PUSH     AF          ; Save character
 1057 06DC FE20                    CP       ' '         ; Is it a control code?
 1058 06DE DAF506                  JP       C,DINPOS    ; Yes - Don't INC POS(X
 1059 06E1 3A8780                  LD       A,(LWIDTH)  ; Get line width
 1060 06E4 47                      LD       B,A         ; To B
 1061 06E5 3AF080                  LD       A,(CURPOS)  ; Get cursor position
 1062 06E8 04                      INC      B           ; Width 255?
 1063 06E9 CAF106                  JP       Z,INCLEN    ; Yes - No width limit
 1064 06EC 05                      DEC      B           ; Restore width
 1065 06ED B8                      CP       B           ; At end of line?
 1066 06EE CCF80A                  CALL     Z,PRCRLF    ; Yes - output CRLF
 1067 06F1 3C           INCLEN:    INC      A           ; Move on one character
 1068 06F2 32F080                  LD       (CURPOS),A  ; Save new position
 1069 06F5 F1           DINPOS:    POP      AF          ; Restore character
 1070 06F6 C1                      POP      BC          ; Restore buffer length
 1071 06F7 CD8D1C                  CALL     MONOUT      ; Send it
 1072 06FA C9                      RET
 1073                   ;
 1074 06FB CD551B       CLOTST:    CALL     GETINP      ; Get input character
 1075 06FE E67F                    AND      01111111B   ; Strip bit 7
 1076 0700 FE0F                    CP       CTRLO       ; Is it control "O"?
 1077 0702 C0                      RET      NZ          ; No don't flip flag
 1078 0703 3A8A80                  LD       A,(CTLOFG)  ; Get flag
 1079 0706 2F                      CPL                  ; Flip it
 1080 0707 328A80                  LD       (CTLOFG),A  ; Put it back
 1081 070A AF                      XOR      A           ; Null character
 1082 070B C9                      RET
 1083                   ;
 1084 070C CD1C09       LIST:      CALL     ATOH        ; ASCII number to DE
 1085 070F C0                      RET      NZ          ; Return if anything ex
 1086 0710 C1                      POP      BC          ; Rubbish - Not needed
 1087 0711 CDE404                  CALL     SRCHLN      ; Search for line numbe
 1088 0714 C5                      PUSH     BC          ; Save address of line
 1089 0715 CD6207                  CALL     SETLIN      ; Set up lines counter
 1090 0718 E1           LISTLP:    POP      HL          ; Restore address of li
 1091 0719 4E                      LD       C,(HL)      ; Get LSB of next line
 1092 071A 23                      INC      HL
 1093 071B 46                      LD       B,(HL)      ; Get MSB of next line
 1094 071C 23                      INC      HL
 1095 071D 78                      LD       A,B         ; BC = 0 (End of progra
 1096 071E B1                      OR       C
 1097 071F CA4304                  JP       Z,PRNTOK    ; Yes - Go to command m
 1098 0722 CD6B07                  CALL     COUNT       ; Count lines
 1099 0725 CD7B08                  CALL     TSTBRK      ; Test for break key
 1100 0728 C5                      PUSH     BC          ; Save address of next 
 1101 0729 CDF80A                  CALL     PRCRLF      ; Output CRLF
 1102 072C 5E                      LD       E,(HL)      ; Get LSB of line numbe
 1103 072D 23                      INC      HL
 1104 072E 56                      LD       D,(HL)      ; Get MSB of line numbe
 1105 072F 23                      INC      HL
 1106 0730 E5                      PUSH     HL          ; Save address of line 
 1107 0731 EB                      EX       DE,HL       ; Line number to HL
 1108 0732 CD3918                  CALL     PRNTHL      ; Output line number in
 1109 0735 3E20                    LD       A,' '       ; Space after line numb
 1110 0737 E1                      POP      HL          ; Restore start of line
 1111 0738 CDD106       LSTLP2:    CALL     OUTC        ; Output character in A
 1112 073B 7E           LSTLP3:    LD       A,(HL)      ; Get next byte in line
 1113 073C B7                      OR       A           ; End of line?
 1114 073D 23                      INC      HL          ; To next byte in line
 1115 073E CA1807                  JP       Z,LISTLP    ; Yes - get next line
 1116 0741 F23807                  JP       P,LSTLP2    ; No token - output it
 1117 0744 D67F                    SUB      ZEND-1      ; Find and output word
 1118 0746 4F                      LD       C,A         ; Token offset+1 to C
 1119 0747 118101                  LD       DE,WORDS    ; Reserved word list
 1120 074A 1A           FNDTOK:    LD       A,(DE)      ; Get character in list
 1121 074B 13                      INC      DE          ; Move on to next
 1122 074C B7                      OR       A           ; Is it start of word?
 1123 074D F24A07                  JP       P,FNDTOK    ; No - Keep looking for
 1124 0750 0D                      DEC      C           ; Count words
 1125 0751 C24A07                  JP       NZ,FNDTOK   ; Not there - keep look
 1126 0754 E67F         OUTWRD:    AND      01111111B   ; Strip bit 7
 1127 0756 CDD106                  CALL     OUTC        ; Output first characte
 1128 0759 1A                      LD       A,(DE)      ; Get next character
 1129 075A 13                      INC      DE          ; Move on to next
 1130 075B B7                      OR       A           ; Is it end of word?
 1131 075C F25407                  JP       P,OUTWRD    ; No - output the rest
 1132 075F C33B07                  JP       LSTLP3      ; Next byte in line
 1133                   ;
 1134 0762 E5           SETLIN:    PUSH     HL          ; Set up LINES counter
 1135 0763 2A8D80                  LD       HL,(LINESN) ; Get LINES number
 1136 0766 228B80                  LD       (LINESC),HL ; Save in LINES counter
 1137 0769 E1                      POP      HL
 1138 076A C9                      RET
 1139                   ;
 1140 076B E5           COUNT:     PUSH     HL          ; Save code string addr
 1141 076C D5                      PUSH     DE
 1142 076D 2A8B80                  LD       HL,(LINESC) ; Get LINES counter
 1143 0770 11FFFF                  LD       DE,-1
 1144 0773 ED5A                    ADC      HL,DE       ; Decrement
 1145 0775 228B80                  LD       (LINESC),HL ; Put it back
 1146 0778 D1                      POP      DE
 1147 0779 E1                      POP      HL          ; Restore code string a
 1148 077A F0                      RET      P           ; Return if more lines 
 1149 077B E5                      PUSH     HL          ; Save code string addr
 1150 077C 2A8D80                  LD       HL,(LINESN) ; Get LINES number
 1151 077F 228B80                  LD       (LINESC),HL ; Reset LINES counter
 1152 0782 CD551B                  CALL     GETINP      ; Get input character
 1153 0785 FE03                    CP       CTRLC       ; Is it control "C"?
 1154 0787 CA8E07                  JP       Z,RSLNBK    ; Yes - Reset LINES and
 1155 078A E1                      POP      HL          ; Restore code string a
 1156 078B C36B07                  JP       COUNT       ; Keep on counting
 1157                   ;
 1158 078E 2A8D80       RSLNBK:    LD       HL,(LINESN) ; Get LINES number
 1159 0791 228B80                  LD       (LINESC),HL ; Reset LINES counter
 1160 0794 C3C200                  JP       BRKRET      ; Go and output "Break"
 1161                   ;
 1162 0797 3E64         FOR:       LD       A,64H       ; Flag "FOR" assignment
 1163 0799 321081                  LD       (FORFLG),A  ; Save "FOR" flag
 1164 079C CDFE09                  CALL     LET         ; Set up initial index
 1165 079F C1                      POP      BC          ; Drop RETurn address
 1166 07A0 E5                      PUSH     HL          ; Save code string addr
 1167 07A1 CDE709                  CALL     DATA        ; Get next statement ad
 1168 07A4 220C81                  LD       (LOOPST),HL ; Save it for start of 
 1169 07A7 210200                  LD       HL,2        ; Offset for "FOR" bloc
 1170 07AA 39                      ADD      HL,SP       ; Point to it
 1171 07AB CDA503       FORSLP:    CALL     LOKFOR      ; Look for existing "FO
 1172 07AE D1                      POP      DE          ; Get code string addre
 1173 07AF C2C707                  JP       NZ,FORFND   ; No nesting found
 1174 07B2 09                      ADD      HL,BC       ; Move into "FOR" block
 1175 07B3 D5                      PUSH     DE          ; Save code string addr
 1176 07B4 2B                      DEC      HL
 1177 07B5 56                      LD       D,(HL)      ; Get MSB of loop state
 1178 07B6 2B                      DEC      HL
 1179 07B7 5E                      LD       E,(HL)      ; Get LSB of loop state
 1180 07B8 23                      INC      HL
 1181 07B9 23                      INC      HL
 1182 07BA E5                      PUSH     HL          ; Save block address
 1183 07BB 2A0C81                  LD       HL,(LOOPST) ; Get address of loop s
 1184 07BE CDC006                  CALL     CPDEHL      ; Compare the FOR loops
 1185 07C1 E1                      POP      HL          ; Restore block address
 1186 07C2 C2AB07                  JP       NZ,FORSLP   ; Different FORs - Find
 1187 07C5 D1                      POP      DE          ; Restore code string a
 1188 07C6 F9                      LD       SP,HL       ; Remove all nested loo
 1189                   ;
 1190 07C7 EB           FORFND:    EX       DE,HL       ; Code string address t
 1191 07C8 0E08                    LD       C,8
 1192 07CA CDD503                  CALL     CHKSTK      ; Check for 8 levels of
 1193 07CD E5                      PUSH     HL          ; Save code string addr
 1194 07CE 2A0C81                  LD       HL,(LOOPST) ; Get first statement o
 1195 07D1 E3                      EX       (SP),HL     ; Save and restore code
 1196 07D2 E5                      PUSH     HL          ; Re-save code string a
 1197 07D3 2AA180                  LD       HL,(LINEAT) ; Get current line numb
 1198 07D6 E3                      EX       (SP),HL     ; Save and restore code
 1199 07D7 CDC00C                  CALL     TSTNUM      ; Make sure it's a numb
 1200 07DA CDC606                  CALL     CHKSYN      ; Make sure "TO" is nex
 1201 07DD A6                      DB       ZTO         ; "TO" token
 1202 07DE CDBD0C                  CALL     GETNUM      ; Get "TO" expression v
 1203 07E1 E5                      PUSH     HL          ; Save code string addr
 1204 07E2 CDEB16                  CALL     BCDEFP      ; Move "TO" value to BC
 1205 07E5 E1                      POP      HL          ; Restore code string a
 1206 07E6 C5                      PUSH     BC          ; Save "TO" value in bl
 1207 07E7 D5                      PUSH     DE
 1208 07E8 010081                  LD       BC,8100H    ; BCDE - 1 (default STE
 1209 07EB 51                      LD       D,C         ; C=0
 1210 07EC 5A                      LD       E,D         ; D=0
 1211 07ED 7E                      LD       A,(HL)      ; Get next byte in code
 1212 07EE FEAB                    CP       ZSTEP       ; See if "STEP" is stat
 1213 07F0 3E01                    LD       A,1         ; Sign of step = 1
 1214 07F2 C20308                  JP       NZ,SAVSTP   ; No STEP given - Defau
 1215 07F5 CD5008                  CALL     GETCHR      ; Jump over "STEP" toke
 1216 07F8 CDBD0C                  CALL     GETNUM      ; Get step value
 1217 07FB E5                      PUSH     HL          ; Save code string addr
 1218 07FC CDEB16                  CALL     BCDEFP      ; Move STEP to BCDE
 1219 07FF CD9F16                  CALL     TSTSGN      ; Test sign of FPREG
 1220 0802 E1                      POP      HL          ; Restore code string a
 1221 0803 C5           SAVSTP:    PUSH     BC          ; Save the STEP value i
 1222 0804 D5                      PUSH     DE
 1223 0805 F5                      PUSH     AF          ; Save sign of STEP
 1224 0806 33                      INC      SP          ; Don't save flags
 1225 0807 E5                      PUSH     HL          ; Save code string addr
 1226 0808 2A1381                  LD       HL,(BRKLIN) ; Get address of index 
 1227 080B E3                      EX       (SP),HL     ; Save and restore code
 1228 080C 0681         PUTFID:    LD       B,ZFOR      ; "FOR" block marker
 1229 080E C5                      PUSH     BC          ; Save it
 1230 080F 33                      INC      SP          ; Don't save C
 1231                   ;
 1232 0810 CD7B08       RUNCNT:    CALL     TSTBRK      ; Execution driver - Te
 1233 0813 221381                  LD       (BRKLIN),HL ; Save code address for
 1234 0816 7E                      LD       A,(HL)      ; Get next byte in code
 1235 0817 FE3A                    CP       ':'         ; Multi statement line?
 1236 0819 CA3008                  JP       Z,EXCUTE    ; Yes - Execute it
 1237 081C B7                      OR       A           ; End of line?
 1238 081D C2F803                  JP       NZ,SNERR    ; No - Syntax error
 1239 0820 23                      INC      HL          ; Point to address of n
 1240 0821 7E                      LD       A,(HL)      ; Get LSB of line point
 1241 0822 23                      INC      HL
 1242 0823 B6                      OR       (HL)        ; Is it zero (End of pr
 1243 0824 CAA208                  JP       Z,ENDPRG    ; Yes - Terminate execu
 1244 0827 23                      INC      HL          ; Point to line number
 1245 0828 5E                      LD       E,(HL)      ; Get LSB of line numbe
 1246 0829 23                      INC      HL
 1247 082A 56                      LD       D,(HL)      ; Get MSB of line numbe
 1248 082B EB                      EX       DE,HL       ; Line number to HL
 1249 082C 22A180                  LD       (LINEAT),HL ; Save as current line 
 1250 082F EB                      EX       DE,HL       ; Line number back to D
 1251 0830 CD5008       EXCUTE:    CALL     GETCHR      ; Get key word
 1252 0833 111008                  LD       DE,RUNCNT   ; Where to RETurn to
 1253 0836 D5                      PUSH     DE          ; Save for RETurn
 1254 0837 C8           IFJMP:     RET      Z           ; Go to RUNCNT if end o
 1255 0838 D680         ONJMP:     SUB      ZEND        ; Is it a token?
 1256 083A DAFE09                  JP       C,LET       ; No - try to assign it
 1257 083D FE25                    CP       ZNEW+1-ZEND ; END to NEW ?
 1258 083F D2F803                  JP       NC,SNERR    ; Not a key word - ?SN 
 1259 0842 07                      RLCA                 ; Double it
 1260 0843 4F                      LD       C,A         ; BC = Offset into tabl
 1261 0844 0600                    LD       B,0
 1262 0846 EB                      EX       DE,HL       ; Save code string addr
 1263 0847 21A002                  LD       HL,WORDTB   ; Keyword address table
 1264 084A 09                      ADD      HL,BC       ; Point to routine addr
 1265 084B 4E                      LD       C,(HL)      ; Get LSB of routine ad
 1266 084C 23                      INC      HL
 1267 084D 46                      LD       B,(HL)      ; Get MSB of routine ad
 1268 084E C5                      PUSH     BC          ; Save routine address
 1269 084F EB                      EX       DE,HL       ; Restore code string a
 1270                   ;
 1271 0850 23           GETCHR:    INC      HL          ; Point to next charact
 1272 0851 7E                      LD       A,(HL)      ; Get next code string 
 1273 0852 FE3A                    CP       ':'         ; Z if ':'
 1274 0854 D0                      RET      NC          ; NC if > "9"
 1275 0855 FE20                    CP       ' '
 1276 0857 CA5008                  JP       Z,GETCHR    ; Skip over spaces
 1277 085A FE30                    CP       '0'
 1278 085C 3F                      CCF                  ; NC if < '0'
 1279 085D 3C                      INC      A           ; Test for zero - Leave
 1280 085E 3D                      DEC      A           ; Z if Null
 1281 085F C9                      RET
 1282                   ;
 1283 0860 EB           RESTOR:    EX       DE,HL       ; Save code string addr
 1284 0861 2AA380                  LD       HL,(BASTXT) ; Point to start of pro
 1285 0864 CA7508                  JP       Z,RESTNL    ; Just RESTORE - reset 
 1286 0867 EB                      EX       DE,HL       ; Restore code string a
 1287 0868 CD1C09                  CALL     ATOH        ; Get line number to DE
 1288 086B E5                      PUSH     HL          ; Save code string addr
 1289 086C CDE404                  CALL     SRCHLN      ; Search for line numbe
 1290 086F 60                      LD       H,B         ; HL = Address of line
 1291 0870 69                      LD       L,C
 1292 0871 D1                      POP      DE          ; Restore code string a
 1293 0872 D2BD09                  JP       NC,ULERR    ; ?UL Error if not foun
 1294 0875 2B           RESTNL:    DEC      HL          ; Byte before DATA stat
 1295 0876 222181       UPDATA:    LD       (NXTDAT),HL ; Update DATA pointer
 1296 0879 EB                      EX       DE,HL       ; Restore code string a
 1297 087A C9                      RET
 1298                   ;
 1299                   
 1300 087B DF           TSTBRK:    RST      18H         ; Check input status
 1301 087C C8                      RET      Z           ; No key, go back
 1302 087D D7                      RST      10H         ; Get the key into A
 1303 087E FE1B                    CP       ESC         ; Escape key?
 1304 0880 2811                    JR       Z,BRK       ; Yes, break
 1305 0882 FE03                    CP       CTRLC       ; <Ctrl-C>
 1306 0884 280D                    JR       Z,BRK       ; Yes, break
 1307 0886 FE13                    CP       CTRLS       ; Stop scrolling?
 1308 0888 C0                      RET      NZ          ; Other key, ignore
 1309                   ;
 1310                   
 1311 0889 D7           STALL:     RST      10H         ; Wait for key
 1312 088A FE11                    CP       CTRLQ       ; Resume scrolling?
 1313 088C C8                      RET      Z           ; Release the chokehold
 1314 088D FE03                    CP       CTRLC       ; Second break?
 1315 088F 2807                    JR       Z,STOP      ; Break during hold exi
 1316 0891 18F6                    JR       STALL       ; Loop until <Ctrl-Q> o
 1317                   ;
 1318 0893 3EFF         BRK        LD       A,0FFH      ; Set BRKFLG
 1319 0895 329280                  LD       (BRKFLG),A  ; Store it
 1320                   ;
 1321                   
 1322 0898 C0           STOP:      RET      NZ          ; Exit if anything else
 1323 0899 F6                      DB       0F6H        ; Flag "STOP"
 1324 089A C0           PEND:      RET      NZ          ; Exit if anything else
 1325 089B 221381                  LD       (BRKLIN),HL ; Save point of break
 1326 089E 21                      DB       21H         ; Skip "OR 11111111B"
 1327 089F F6FF         INPBRK:    OR       11111111B   ; Flag "Break" wanted
 1328 08A1 C1                      POP      BC          ; Return not needed and
 1329 08A2 2AA180       ENDPRG:    LD       HL,(LINEAT) ; Get current line numb
 1330 08A5 F5                      PUSH     AF          ; Save STOP / END statu
 1331 08A6 7D                      LD       A,L         ; Is it direct break?
 1332 08A7 A4                      AND      H
 1333 08A8 3C                      INC      A           ; Line is -1 if direct 
 1334 08A9 CAB508                  JP       Z,NOLIN     ; Yes - No line number
 1335 08AC 221781                  LD       (ERRLIN),HL ; Save line of break
 1336 08AF 2A1381                  LD       HL,(BRKLIN) ; Get point of break
 1337 08B2 221981                  LD       (CONTAD),HL ; Save point to CONTinu
 1338 08B5 AF           NOLIN:     XOR      A
 1339 08B6 328A80                  LD       (CTLOFG),A  ; Enable output
 1340 08B9 CDEB0A                  CALL     STTLIN      ; Start a new line
 1341 08BC F1                      POP      AF          ; Restore STOP / END st
 1342 08BD 219B03                  LD       HL,BRKMSG   ; "Break" message
 1343 08C0 C22C04                  JP       NZ,ERRIN    ; "in line" wanted?
 1344 08C3 C34304                  JP       PRNTOK      ; Go to command mode
 1345                   ;
 1346 08C6 2A1981       CONT:      LD       HL,(CONTAD) ; Get CONTinue address
 1347 08C9 7C                      LD       A,H         ; Is it zero?
 1348 08CA B5                      OR       L
 1349 08CB 1E20                    LD       E,CN        ; ?CN Error
 1350 08CD CA0C04                  JP       Z,ERROR     ; Yes - output "?CN Err
 1351 08D0 EB                      EX       DE,HL       ; Save code string addr
 1352 08D1 2A1781                  LD       HL,(ERRLIN) ; Get line of last brea
 1353 08D4 22A180                  LD       (LINEAT),HL ; Set up current line n
 1354 08D7 EB                      EX       DE,HL       ; Restore code string a
 1355 08D8 C9                      RET                  ; CONTinue where left o
 1356                   ;
 1357 08D9 CD1E14       NULL:      CALL     GETINT      ; Get integer 0-255
 1358 08DC C0                      RET      NZ          ; Return if bad value
 1359 08DD 328680                  LD       (NULLS),A   ; Set nulls number
 1360 08E0 C9                      RET
 1361                   ;
 1362                   
 1363 08E1 E5           ACCSUM:    PUSH     HL          ; Save address in array
 1364 08E2 2A8F80                  LD       HL,(CHKSUM) ; Get check sum
 1365 08E5 0600                    LD       B,0         ; BC - Value of byte
 1366 08E7 4F                      LD       C,A
 1367 08E8 09                      ADD      HL,BC       ; Add byte to check sum
 1368 08E9 228F80                  LD       (CHKSUM),HL ; Re-save check sum
 1369 08EC E1                      POP      HL          ; Restore address in ar
 1370 08ED C9                      RET
 1371                   ;
 1372 08EE 7E           CHKLTR:    LD       A,(HL)      ; Get byte
 1373 08EF FE41                    CP       'A'         ; < 'a' ?
 1374 08F1 D8                      RET      C           ; Carry set if not lett
 1375 08F2 FE5B                    CP       'Z'+1       ; > 'z' ?
 1376 08F4 3F                      CCF
 1377 08F5 C9                      RET                  ; Carry set if not lett
 1378                   ;
 1379 08F6 CD5008       FPSINT:    CALL     GETCHR      ; Get next character
 1380 08F9 CDBD0C       POSINT:    CALL     GETNUM      ; Get integer 0 to 3276
 1381 08FC CD9F16       DEPINT:    CALL     TSTSGN      ; Test sign of FPREG
 1382 08FF FA1709                  JP       M,FCERR     ; Negative - ?FC Error
 1383 0902 3A2C81       DEINT:     LD       A,(FPEXP)   ; Get integer value to 
 1384 0905 FE90                    CP       80H+16      ; Exponent in range (16
 1385 0907 DA4717                  JP       C,FPINT     ; Yes - convert it
 1386 090A 018090                  LD       BC,9080H    ; BCDE = -32768
 1387 090D 110000                  LD       DE,0000
 1388 0910 E5                      PUSH     HL          ; Save code string addr
 1389 0911 CD1A17                  CALL     CMPNUM      ; Compare FPREG with BC
 1390 0914 E1                      POP      HL          ; Restore code string a
 1391 0915 51                      LD       D,C         ; MSB to D
 1392 0916 C8                      RET      Z           ; Return if in range
 1393 0917 1E08         FCERR:     LD       E,FC        ; ?FC Error
 1394 0919 C30C04                  JP       ERROR       ; Output error-
 1395                   ;
 1396 091C 2B           ATOH:      DEC      HL          ; ASCII number to DE bi
 1397 091D 110000       GETLN:     LD       DE,0        ; Get number to DE
 1398 0920 CD5008       GTLNLP:    CALL     GETCHR      ; Get next character
 1399 0923 D0                      RET      NC          ; Exit if not a digit
 1400 0924 E5                      PUSH     HL          ; Save code string addr
 1401 0925 F5                      PUSH     AF          ; Save digit
 1402 0926 219819                  LD       HL,65529/10 ; Largest number 65529
 1403 0929 CDC006                  CALL     CPDEHL      ; Number in range?
 1404 092C DAF803                  JP       C,SNERR     ; No - ?SN Error
 1405 092F 62                      LD       H,D         ; HL = Number
 1406 0930 6B                      LD       L,E
 1407 0931 19                      ADD      HL,DE       ; Times 2
 1408 0932 29                      ADD      HL,HL       ; Times 4
 1409 0933 19                      ADD      HL,DE       ; Times 5
 1410 0934 29                      ADD      HL,HL       ; Times 10
 1411 0935 F1                      POP      AF          ; Restore digit
 1412 0936 D630                    SUB      '0'         ; Make it 0 to 9
 1413 0938 5F                      LD       E,A         ; DE = Value of digit
 1414 0939 1600                    LD       D,0
 1415 093B 19                      ADD      HL,DE       ; Add to number
 1416 093C EB                      EX       DE,HL       ; Number to DE
 1417 093D E1                      POP      HL          ; Restore code string a
 1418 093E C32009                  JP       GTLNLP      ; Go to next character
 1419                   ;
 1420 0941 CA1405       CLEAR:     JP       Z,INTVAR    ; Just "CLEAR" Keep par
 1421 0944 CDF908                  CALL     POSINT      ; Get integer 0 to 3276
 1422 0947 2B                      DEC      HL          ; Cancel increment
 1423 0948 CD5008                  CALL     GETCHR      ; Get next character
 1424 094B E5                      PUSH     HL          ; Save code string addr
 1425 094C 2AF480                  LD       HL,(LSTRAM) ; Get end of RAM
 1426 094F CA6409                  JP       Z,STORED    ; No value given - Use 
 1427 0952 E1                      POP      HL          ; Restore code string a
 1428 0953 CDC606                  CALL     CHKSYN      ; Check for comma
 1429 0956 2C                      DB       ','
 1430 0957 D5                      PUSH     DE          ; Save number
 1431 0958 CDF908                  CALL     POSINT      ; Get integer 0 to 3276
 1432 095B 2B                      DEC      HL          ; Cancel increment
 1433 095C CD5008                  CALL     GETCHR      ; Get next character
 1434 095F C2F803                  JP       NZ,SNERR    ; ?SN Error if more on 
 1435 0962 E3                      EX       (SP),HL     ; Save code string addr
 1436 0963 EB                      EX       DE,HL       ; Number to DE
 1437 0964 7D           STORED:    LD       A,L         ; Get LSB of new RAM to
 1438 0965 93                      SUB      E           ; Subtract LSB of strin
 1439 0966 5F                      LD       E,A         ; Save LSB
 1440 0967 7C                      LD       A,H         ; Get MSB of new RAM to
 1441 0968 9A                      SBC      A,D         ; Subtract MSB of strin
 1442 0969 57                      LD       D,A         ; Save MSB
 1443 096A DAED03                  JP       C,OMERR     ; ?OM Error if not enou
 1444 096D E5                      PUSH     HL          ; Save RAM top
 1445 096E 2A1B81                  LD       HL,(PROGND) ; Get program end
 1446 0971 012800                  LD       BC,40       ; 40 Bytes minimum work
 1447 0974 09                      ADD      HL,BC       ; Get lowest address
 1448 0975 CDC006                  CALL     CPDEHL      ; Enough memory?
 1449 0978 D2ED03                  JP       NC,OMERR    ; No - ?OM Error
 1450 097B EB                      EX       DE,HL       ; RAM top to HL
 1451 097C 229F80                  LD       (STRSPC),HL ; Set new string space
 1452 097F E1                      POP      HL          ; End of memory to use
 1453 0980 22F480                  LD       (LSTRAM),HL ; Set new top of RAM
 1454 0983 E1                      POP      HL          ; Restore code string a
 1455 0984 C31405                  JP       INTVAR      ; Initialise variables
 1456                   ;
 1457 0987 CA1005       RUN:       JP       Z,RUNFST    ; RUN from start if jus
 1458 098A CD1405                  CALL     INTVAR      ; Initialise variables
 1459 098D 011008                  LD       BC,RUNCNT   ; Execution driver loop
 1460 0990 C3A309                  JP       RUNLIN      ; RUN from line number
 1461                   ;
 1462 0993 0E03         GOSUB:     LD       C,3         ; 3 Levels of stack nee
 1463 0995 CDD503                  CALL     CHKSTK      ; Check for 3 levels of
 1464 0998 C1                      POP      BC          ; Get return address
 1465 0999 E5                      PUSH     HL          ; Save code string for 
 1466 099A E5                      PUSH     HL          ; And for GOSUB routine
 1467 099B 2AA180                  LD       HL,(LINEAT) ; Get current line
 1468 099E E3                      EX       (SP),HL     ; Into stack - Code str
 1469 099F 3E8C                    LD       A,ZGOSUB    ; "GOSUB" token
 1470 09A1 F5                      PUSH     AF          ; Save token
 1471 09A2 33                      INC      SP          ; Don't save flags
 1472                   ;
 1473 09A3 C5           RUNLIN:    PUSH     BC          ; Save return address
 1474 09A4 CD1C09       GOTO:      CALL     ATOH        ; ASCII number to DE bi
 1475 09A7 CDE909                  CALL     REM         ; Get end of line
 1476 09AA E5                      PUSH     HL          ; Save end of line
 1477 09AB 2AA180                  LD       HL,(LINEAT) ; Get current line
 1478 09AE CDC006                  CALL     CPDEHL      ; Line after current?
 1479 09B1 E1                      POP      HL          ; Restore end of line
 1480 09B2 23                      INC      HL          ; Start of next line
 1481 09B3 DCE704                  CALL     C,SRCHLP    ; Line is after current
 1482 09B6 D4E404                  CALL     NC,SRCHLN   ; Line is before curren
 1483 09B9 60                      LD       H,B         ; Set up code string ad
 1484 09BA 69                      LD       L,C
 1485 09BB 2B                      DEC      HL          ; Incremented after
 1486 09BC D8                      RET      C           ; Line found
 1487 09BD 1E0E         ULERR:     LD       E,UL        ; ?UL Error
 1488 09BF C30C04                  JP       ERROR       ; Output error message
 1489                   ;
 1490 09C2 C0           RETURN:    RET      NZ          ; Return if not just RE
 1491 09C3 16FF                    LD       D,-1        ; Flag "GOSUB" search
 1492 09C5 CDA103                  CALL     BAKSTK      ; Look "GOSUB" block
 1493 09C8 F9                      LD       SP,HL       ; Kill all FORs in subr
 1494 09C9 FE8C                    CP       ZGOSUB      ; Test for "GOSUB" toke
 1495 09CB 1E04                    LD       E,RG        ; ?RG Error
 1496 09CD C20C04                  JP       NZ,ERROR    ; Error if no "GOSUB" f
 1497 09D0 E1                      POP      HL          ; Get RETURN line numbe
 1498 09D1 22A180                  LD       (LINEAT),HL ; Save as current
 1499 09D4 23                      INC      HL          ; Was it from direct st
 1500 09D5 7C                      LD       A,H
 1501 09D6 B5                      OR       L           ; Return to line
 1502 09D7 C2E109                  JP       NZ,RETLIN   ; No - Return to line
 1503 09DA 3A1181                  LD       A,(LSTBIN)  ; Any INPUT in subrouti
 1504 09DD B7                      OR       A           ; If so buffer is corru
 1505 09DE C24204                  JP       NZ,POPNOK   ; Yes - Go to command m
 1506 09E1 211008       RETLIN:    LD       HL,RUNCNT   ; Execution driver loop
 1507 09E4 E3                      EX       (SP),HL     ; Into stack - Code str
 1508 09E5 3E                      DB       3EH         ; Skip "POP HL"
 1509 09E6 E1           NXTDTA:    POP      HL          ; Restore code string a
 1510                   ;
 1511 09E7 013A         DATA:      DB       01H,3AH     ; ':' End of statement
 1512 09E9 0E00         REM:       LD       C,0         ; 00    End of statemen
 1513 09EB 0600                    LD       B,0
 1514 09ED 79           NXTSTL:    LD       A,C         ; Statement and byte
 1515 09EE 48                      LD       C,B
 1516 09EF 47                      LD       B,A         ; Statement end byte
 1517 09F0 7E           NXTSTT:    LD       A,(HL)      ; Get byte
 1518 09F1 B7                      OR       A           ; End of line?
 1519 09F2 C8                      RET      Z           ; Yes - Exit
 1520 09F3 B8                      CP       B           ; End of statement?
 1521 09F4 C8                      RET      Z           ; Yes - Exit
 1522 09F5 23                      INC      HL          ; Next byte
 1523 09F6 FE22                    CP       '"'         ; Literal string?
 1524 09F8 CAED09                  JP       Z,NXTSTL    ; Yes - Look for anothe
 1525 09FB C3F009                  JP       NXTSTT      ; Keep looking
 1526                   ;
 1527 09FE CDB30E       LET:       CALL     GETVAR      ; Get variable name
 1528 0A01 CDC606                  CALL     CHKSYN      ; Make sure "=" follows
 1529 0A04 B4                      DB       ZEQUAL      ; "=" token
 1530 0A05 D5                      PUSH     DE          ; Save address of varia
 1531 0A06 3AF280                  LD       A,(TYPE)    ; Get data type
 1532 0A09 F5                      PUSH     AF          ; Save type
 1533 0A0A CDCF0C                  CALL     EVAL        ; Evaluate expression
 1534 0A0D F1                      POP      AF          ; Restore type
 1535 0A0E E3                      EX       (SP),HL     ; Save code - Get var a
 1536 0A0F 221381                  LD       (BRKLIN),HL ; Save address of varia
 1537 0A12 1F                      RRA                  ; Adjust type
 1538 0A13 CDC20C                  CALL     CHKTYP      ; Check types are the s
 1539 0A16 CA510A                  JP       Z,LETNUM    ; Numeric - Move value
 1540 0A19 E5           LETSTR:    PUSH     HL          ; Save address of strin
 1541 0A1A 2A2981                  LD       HL,(FPREG)  ; Pointer to string ent
 1542 0A1D E5                      PUSH     HL          ; Save it on stack
 1543 0A1E 23                      INC      HL          ; Skip over length
 1544 0A1F 23                      INC      HL
 1545 0A20 5E                      LD       E,(HL)      ; LSB of string address
 1546 0A21 23                      INC      HL
 1547 0A22 56                      LD       D,(HL)      ; MSB of string address
 1548 0A23 2AA380                  LD       HL,(BASTXT) ; Point to start of pro
 1549 0A26 CDC006                  CALL     CPDEHL      ; Is string before prog
 1550 0A29 D2400A                  JP       NC,CRESTR   ; Yes - Create string e
 1551 0A2C 2A9F80                  LD       HL,(STRSPC) ; Point to string space
 1552 0A2F CDC006                  CALL     CPDEHL      ; Is string literal in 
 1553 0A32 D1                      POP      DE          ; Restore address of st
 1554 0A33 D2480A                  JP       NC,MVSTPT   ; Yes - Set up pointer
 1555 0A36 210481                  LD       HL,TMPSTR   ; Temporary string pool
 1556 0A39 CDC006                  CALL     CPDEHL      ; Is string in temporar
 1557 0A3C D2480A                  JP       NC,MVSTPT   ; No - Set up pointer
 1558 0A3F 3E                      DB       3EH         ; Skip "POP DE"
 1559 0A40 D1           CRESTR:    POP      DE          ; Restore address of st
 1560 0A41 CDF712                  CALL     BAKTMP      ; Back to last tmp-str 
 1561 0A44 EB                      EX       DE,HL       ; Address of string ent
 1562 0A45 CD3011                  CALL     SAVSTR      ; Save string in string
 1563 0A48 CDF712       MVSTPT:    CALL     BAKTMP      ; Back to last tmp-str 
 1564 0A4B E1                      POP      HL          ; Get string pointer
 1565 0A4C CDFA16                  CALL     DETHL4      ; Move string pointer t
 1566 0A4F E1                      POP      HL          ; Restore code string a
 1567 0A50 C9                      RET
 1568                   ;
 1569 0A51 E5           LETNUM:    PUSH     HL          ; Save address of varia
 1570 0A52 CDF716                  CALL     FPTHL       ; Move value to variabl
 1571 0A55 D1                      POP      DE          ; Restore address of va
 1572 0A56 E1                      POP      HL          ; Restore code string a
 1573 0A57 C9                      RET
 1574                   ;
 1575 0A58 CD1E14       ON:        CALL     GETINT      ; Get integer 0-255
 1576 0A5B 7E                      LD       A,(HL)      ; Get "GOTO" or "GOSUB"
 1577 0A5C 47                      LD       B,A         ; Save in B
 1578 0A5D FE8C                    CP       ZGOSUB      ; "GOSUB" token?
 1579 0A5F CA670A                  JP       Z,ONGO      ; Yes - Find line numbe
 1580 0A62 CDC606                  CALL     CHKSYN      ; Make sure it's "GOTO"
 1581 0A65 88                      DB       ZGOTO       ; "GOTO" token
 1582 0A66 2B                      DEC      HL          ; Cancel increment
 1583 0A67 4B           ONGO:      LD       C,E         ; Integer of branch val
 1584 0A68 0D           ONGOLP:    DEC      C           ; Count branches
 1585 0A69 78                      LD       A,B         ; Get "GOTO" or "GOSUB"
 1586 0A6A CA3808                  JP       Z,ONJMP     ; Go to that line if ri
 1587 0A6D CD1D09                  CALL     GETLN       ; Get line number to DE
 1588 0A70 FE2C                    CP       ','         ; Another line number?
 1589 0A72 C0                      RET      NZ          ; No - Drop through
 1590 0A73 C3680A                  JP       ONGOLP      ; Yes - loop
 1591                   ;
 1592 0A76 CDCF0C       IF:        CALL     EVAL        ; Evaluate expression
 1593 0A79 7E                      LD       A,(HL)      ; Get token
 1594 0A7A FE88                    CP       ZGOTO       ; "GOTO" token?
 1595 0A7C CA840A                  JP       Z,IFGO      ; Yes - Get line
 1596 0A7F CDC606                  CALL     CHKSYN      ; Make sure it's "THEN"
 1597 0A82 A9                      DB       ZTHEN       ; "THEN" token
 1598 0A83 2B                      DEC      HL          ; Cancel increment
 1599 0A84 CDC00C       IFGO:      CALL     TSTNUM      ; Make sure it's numeri
 1600 0A87 CD9F16                  CALL     TSTSGN      ; Test state of express
 1601 0A8A CAE909                  JP       Z,REM       ; False - Drop through
 1602 0A8D CD5008                  CALL     GETCHR      ; Get next character
 1603 0A90 DAA409                  JP       C,GOTO      ; Number - GOTO that li
 1604 0A93 C33708                  JP       IFJMP       ; Otherwise do statemen
 1605                   ;
 1606 0A96 2B           MRPRNT:    DEC      HL          ; DEC 'cos GETCHR INCs
 1607 0A97 CD5008                  CALL     GETCHR      ; Get next character
 1608 0A9A CAF80A       PRINT:     JP       Z,PRCRLF    ; CRLF if just PRINT
 1609 0A9D C8           PRNTLP:    RET      Z           ; End of list - Exit
 1610 0A9E FEA5                    CP       ZTAB        ; "TAB(" token?
 1611 0AA0 CA2B0B                  JP       Z,DOTAB     ; Yes - Do TAB routine
 1612 0AA3 FEA8                    CP       ZSPC        ; "SPC(" token?
 1613 0AA5 CA2B0B                  JP       Z,DOTAB     ; Yes - Do SPC routine
 1614 0AA8 E5                      PUSH     HL          ; Save code string addr
 1615 0AA9 FE2C                    CP       ','         ; Comma?
 1616 0AAB CA140B                  JP       Z,DOCOM     ; Yes - Move to next zo
 1617 0AAE FE3B                    CP       59          ;";"          ; Semi-co
 1618 0AB0 CA4E0B                  JP       Z,NEXITM    ; Do semi-colon routine
 1619 0AB3 C1                      POP      BC          ; Code string address t
 1620 0AB4 CDCF0C                  CALL     EVAL        ; Evaluate expression
 1621 0AB7 E5                      PUSH     HL          ; Save code string addr
 1622 0AB8 3AF280                  LD       A,(TYPE)    ; Get variable type
 1623 0ABB B7                      OR       A           ; Is it a string variab
 1624 0ABC C2E40A                  JP       NZ,PRNTST   ; Yes - Output string c
 1625 0ABF CD4418                  CALL     NUMASC      ; Convert number to tex
 1626 0AC2 CD5411                  CALL     CRTST       ; Create temporary stri
 1627 0AC5 3620                    LD       (HL),' '    ; Followed by a space
 1628 0AC7 2A2981                  LD       HL,(FPREG)  ; Get length of output
 1629 0ACA 34                      INC      (HL)        ; Plus 1 for the space
 1630 0ACB 2A2981                  LD       HL,(FPREG)  ; < Not needed >
 1631 0ACE 3A8780                  LD       A,(LWIDTH)  ; Get width of line
 1632 0AD1 47                      LD       B,A         ; To B
 1633 0AD2 04                      INC      B           ; Width 255 (No limit)?
 1634 0AD3 CAE00A                  JP       Z,PRNTNB    ; Yes - Output number s
 1635 0AD6 04                      INC      B           ; Adjust it
 1636 0AD7 3AF080                  LD       A,(CURPOS)  ; Get cursor position
 1637 0ADA 86                      ADD      A,(HL)      ; Add length of string
 1638 0ADB 3D                      DEC      A           ; Adjust it
 1639 0ADC B8                      CP       B           ; Will output fit on th
 1640 0ADD D4F80A                  CALL     NC,PRCRLF   ; No - CRLF first
 1641 0AE0 CD9911       PRNTNB:    CALL     PRS1        ; Output string at (HL)
 1642 0AE3 AF                      XOR      A           ; Skip CALL by setting 
 1643 0AE4 C49911       PRNTST:    CALL     NZ,PRS1     ; Output string at (HL)
 1644 0AE7 E1                      POP      HL          ; Restore code string a
 1645 0AE8 C3960A                  JP       MRPRNT      ; See if more to PRINT
 1646                   ;
 1647 0AEB 3AF080       STTLIN:    LD       A,(CURPOS)  ; Make sure on new line
 1648 0AEE B7                      OR       A           ; Already at start?
 1649 0AEF C8                      RET      Z           ; Yes - Do nothing
 1650 0AF0 C3F80A                  JP       PRCRLF      ; Start a new line
 1651                   ;
 1652 0AF3 3600         ENDINP:    LD       (HL),0      ; Mark end of buffer
 1653 0AF5 21A580                  LD       HL,BUFFER-1 ; Point to buffer
 1654 0AF8 3E0D         PRCRLF:    LD       A,CR        ; Load a CR
 1655 0AFA CDD106                  CALL     OUTC        ; Output character
 1656 0AFD 3E0A                    LD       A,LF        ; Load a LF
 1657 0AFF CDD106                  CALL     OUTC        ; Output character
 1658 0B02 AF           DONULL:    XOR      A           ; Set to position 0
 1659 0B03 32F080                  LD       (CURPOS),A  ; Store it
 1660 0B06 3A8680                  LD       A,(NULLS)   ; Get number of nulls
 1661 0B09 3D           NULLP:     DEC      A           ; Count them
 1662 0B0A C8                      RET      Z           ; Return if done
 1663 0B0B F5                      PUSH     AF          ; Save count
 1664 0B0C AF                      XOR      A           ; Load a null
 1665 0B0D CDD106                  CALL     OUTC        ; Output it
 1666 0B10 F1                      POP      AF          ; Restore count
 1667 0B11 C3090B                  JP       NULLP       ; Keep counting
 1668                   ;
 1669 0B14 3A8880       DOCOM:     LD       A,(COMMAN)  ; Get comma width
 1670 0B17 47                      LD       B,A         ; Save in B
 1671 0B18 3AF080                  LD       A,(CURPOS)  ; Get current position
 1672 0B1B B8                      CP       B           ; Within the limit?
 1673 0B1C D4F80A                  CALL     NC,PRCRLF   ; No - output CRLF
 1674 0B1F D24E0B                  JP       NC,NEXITM   ; Get next item
 1675 0B22 D60E         ZONELP:    SUB      14          ; Next zone of 14 chara
 1676 0B24 D2220B                  JP       NC,ZONELP   ; Repeat if more zones
 1677 0B27 2F                      CPL                  ; Number of spaces to o
 1678 0B28 C3430B                  JP       ASPCS       ; Output them
 1679                   ;
 1680 0B2B F5           DOTAB:     PUSH     AF          ; Save token
 1681 0B2C CD1B14                  CALL     FNDNUM      ; Evaluate expression
 1682 0B2F CDC606                  CALL     CHKSYN      ; Make sure ")" follows
 1683 0B32 29                      DB       ")"
 1684 0B33 2B                      DEC      HL          ; Back space on to ")"
 1685 0B34 F1                      POP      AF          ; Restore token
 1686 0B35 D6A8                    SUB      ZSPC        ; Was it "SPC(" ?
 1687 0B37 E5                      PUSH     HL          ; Save code string addr
 1688 0B38 CA3E0B                  JP       Z,DOSPC     ; Yes - Do 'E' spaces
 1689 0B3B 3AF080                  LD       A,(CURPOS)  ; Get current position
 1690 0B3E 2F           DOSPC:     CPL                  ; Number of spaces to p
 1691 0B3F 83                      ADD      A,E         ; Total number to print
 1692 0B40 D24E0B                  JP       NC,NEXITM   ; TAB < Current POS(X)
 1693 0B43 3C           ASPCS:     INC      A           ; Output A spaces
 1694 0B44 47                      LD       B,A         ; Save number to print
 1695 0B45 3E20                    LD       A,' '       ; Space
 1696 0B47 CDD106       SPCLP:     CALL     OUTC        ; Output character in A
 1697 0B4A 05                      DEC      B           ; Count them
 1698 0B4B C2470B                  JP       NZ,SPCLP    ; Repeat if more
 1699 0B4E E1           NEXITM:    POP      HL          ; Restore code string a
 1700 0B4F CD5008                  CALL     GETCHR      ; Get next character
 1701 0B52 C39D0A                  JP       PRNTLP      ; More to print
 1702                   ;
 1703 0B55 3F5265646F20 REDO:      DB       "?Redo from start",CR,LF,0
           66726F6D2073 
           746172740D0A 
           00           
 1704                   ;
 1705 0B68 3A1281       BADINP:    LD       A,(READFG)  ; READ or INPUT?
 1706 0B6B B7                      OR       A
 1707 0B6C C2F203                  JP       NZ,DATSNR   ; READ - ?SN Error
 1708 0B6F C1                      POP      BC          ; Throw away code strin
 1709 0B70 21550B                  LD       HL,REDO     ; "Redo from start" mes
 1710 0B73 CD9611                  CALL     PRS         ; Output string
 1711 0B76 C34305                  JP       DOAGN       ; Do last INPUT again
 1712                   ;
 1713 0B79 CD0111       INPUT:     CALL     IDTEST      ; Test for illegal dire
 1714 0B7C 7E                      LD       A,(HL)      ; Get character after "
 1715 0B7D FE22                    CP       '"'         ; Is there a prompt str
 1716 0B7F 3E00                    LD       A,0         ; Clear A and leave fla
 1717 0B81 328A80                  LD       (CTLOFG),A  ; Enable output
 1718 0B84 C2930B                  JP       NZ,NOPMPT   ; No prompt - get input
 1719 0B87 CD5511                  CALL     QTSTR       ; Get string terminated
 1720 0B8A CDC606                  CALL     CHKSYN      ; Check for ';' after p
 1721 0B8D 3B                      DB       ';'
 1722 0B8E E5                      PUSH     HL          ; Save code string addr
 1723 0B8F CD9911                  CALL     PRS1        ; Output prompt string
 1724 0B92 3E                      DB       3EH         ; Skip "PUSH HL"
 1725 0B93 E5           NOPMPT:    PUSH     HL          ; Save code string addr
 1726 0B94 CD4705                  CALL     PROMPT      ; Get input with "? " p
 1727 0B97 C1                      POP      BC          ; Restore code string a
 1728 0B98 DA9F08                  JP       C,INPBRK    ; Break pressed - Exit
 1729 0B9B 23                      INC      HL          ; Next byte
 1730 0B9C 7E                      LD       A,(HL)      ; Get it
 1731 0B9D B7                      OR       A           ; End of line?
 1732 0B9E 2B                      DEC      HL          ; Back again
 1733 0B9F C5                      PUSH     BC          ; Re-save code string a
 1734 0BA0 CAE609                  JP       Z,NXTDTA    ; Yes - Find next DATA 
 1735 0BA3 362C                    LD       (HL),','    ; Store comma as separa
 1736 0BA5 C3AD0B                  JP       NXTITM      ; Get next item
 1737                   ;
 1738 0BA8 E5           READ:      PUSH     HL          ; Save code string addr
 1739 0BA9 2A2181                  LD       HL,(NXTDAT) ; Next DATA statement
 1740 0BAC F6                      DB       0F6H        ; Flag "READ"
 1741 0BAD AF           NXTITM:    XOR      A           ; Flag "INPUT"
 1742 0BAE 321281                  LD       (READFG),A  ; Save "READ"/"INPUT" f
 1743 0BB1 E3                      EX       (SP),HL     ; Get code str' , Save 
 1744 0BB2 C3B90B                  JP       GTVLUS      ; Get values
 1745                   ;
 1746 0BB5 CDC606       NEDMOR:    CALL     CHKSYN      ; Check for comma betwe
 1747 0BB8 2C                      DB       ','
 1748 0BB9 CDB30E       GTVLUS:    CALL     GETVAR      ; Get variable name
 1749 0BBC E3                      EX       (SP),HL     ; Save code str" , Get 
 1750 0BBD D5                      PUSH     DE          ; Save variable address
 1751 0BBE 7E                      LD       A,(HL)      ; Get next "INPUT"/"DAT
 1752 0BBF FE2C                    CP       ','         ; Comma?
 1753 0BC1 CAE10B                  JP       Z,ANTVLU    ; Yes - Get another val
 1754 0BC4 3A1281                  LD       A,(READFG)  ; Is it READ?
 1755 0BC7 B7                      OR       A
 1756 0BC8 C24E0C                  JP       NZ,FDTLP    ; Yes - Find next DATA 
 1757 0BCB 3E3F                    LD       A,'?'       ; More INPUT needed
 1758 0BCD CDD106                  CALL     OUTC        ; Output character
 1759 0BD0 CD4705                  CALL     PROMPT      ; Get INPUT with prompt
 1760 0BD3 D1                      POP      DE          ; Variable address
 1761 0BD4 C1                      POP      BC          ; Code string address
 1762 0BD5 DA9F08                  JP       C,INPBRK    ; Break pressed
 1763 0BD8 23                      INC      HL          ; Point to next DATA by
 1764 0BD9 7E                      LD       A,(HL)      ; Get byte
 1765 0BDA B7                      OR       A           ; Is it zero (No input)
 1766 0BDB 2B                      DEC      HL          ; Back space INPUT poin
 1767 0BDC C5                      PUSH     BC          ; Save code string addr
 1768 0BDD CAE609                  JP       Z,NXTDTA    ; Find end of buffer
 1769 0BE0 D5                      PUSH     DE          ; Save variable address
 1770 0BE1 3AF280       ANTVLU:    LD       A,(TYPE)    ; Check data type
 1771 0BE4 B7                      OR       A           ; Is it numeric?
 1772 0BE5 CA0B0C                  JP       Z,INPBIN    ; Yes - Convert to bina
 1773 0BE8 CD5008                  CALL     GETCHR      ; Get next character
 1774 0BEB 57                      LD       D,A         ; Save input character
 1775 0BEC 47                      LD       B,A         ; Again
 1776 0BED FE22                    CP       '"'         ; Start of literal stin
 1777 0BEF CAFF0B                  JP       Z,STRENT    ; Yes - Create string e
 1778 0BF2 3A1281                  LD       A,(READFG)  ; "READ" or "INPUT" ?
 1779 0BF5 B7                      OR       A
 1780 0BF6 57                      LD       D,A         ; Save 00 if "INPUT"
 1781 0BF7 CAFC0B                  JP       Z,ITMSEP    ; "INPUT" - End with 00
 1782 0BFA 163A                    LD       D,':'       ; "DATA" - End with 00 
 1783 0BFC 062C         ITMSEP:    LD       B,','       ; Item separator
 1784 0BFE 2B                      DEC      HL          ; Back space for DTSTR
 1785 0BFF CD5811       STRENT:    CALL     DTSTR       ; Get string terminated
 1786 0C02 EB                      EX       DE,HL       ; String address to DE
 1787 0C03 21160C                  LD       HL,LTSTND   ; Where to go after LET
 1788 0C06 E3                      EX       (SP),HL     ; Save HL , get input p
 1789 0C07 D5                      PUSH     DE          ; Save address of strin
 1790 0C08 C3190A                  JP       LETSTR      ; Assign string to vari
 1791                   ;
 1792 0C0B CD5008       INPBIN:    CALL     GETCHR      ; Get next character
 1793 0C0E CDA617                  CALL     ASCTFP      ; Convert ASCII to FP n
 1794 0C11 E3                      EX       (SP),HL     ; Save input ptr, Get v
 1795 0C12 CDF716                  CALL     FPTHL       ; Move FPREG to variabl
 1796 0C15 E1                      POP      HL          ; Restore input pointer
 1797 0C16 2B           LTSTND:    DEC      HL          ; DEC 'cos GETCHR INCs
 1798 0C17 CD5008                  CALL     GETCHR      ; Get next character
 1799 0C1A CA220C                  JP       Z,MORDT     ; End of line - More ne
 1800 0C1D FE2C                    CP       ','         ; Another value?
 1801 0C1F C2680B                  JP       NZ,BADINP   ; No - Bad input
 1802 0C22 E3           MORDT:     EX       (SP),HL     ; Get code string addre
 1803 0C23 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 1804 0C24 CD5008                  CALL     GETCHR      ; Get next character
 1805 0C27 C2B50B                  JP       NZ,NEDMOR   ; More needed - Get it
 1806 0C2A D1                      POP      DE          ; Restore DATA pointer
 1807 0C2B 3A1281                  LD       A,(READFG)  ; "READ" or "INPUT" ?
 1808 0C2E B7                      OR       A
 1809 0C2F EB                      EX       DE,HL       ; DATA pointer to HL
 1810 0C30 C27608                  JP       NZ,UPDATA   ; Update DATA pointer i
 1811 0C33 D5                      PUSH     DE          ; Save code string addr
 1812 0C34 B6                      OR       (HL)        ; More input given?
 1813 0C35 213D0C                  LD       HL,EXTIG    ; "?Extra ignored" mess
 1814 0C38 C49611                  CALL     NZ,PRS      ; Output string if extr
 1815 0C3B E1                      POP      HL          ; Restore code string a
 1816 0C3C C9                      RET
 1817                   ;
 1818 0C3D 3F4578747261 EXTIG:     DB       "?Extra ignored",CR,LF,0
           2069676E6F72 
           65640D0A00   
 1819                   ;
 1820 0C4E CDE709       FDTLP:     CALL     DATA        ; Get next statement
 1821 0C51 B7                      OR       A           ; End of line?
 1822 0C52 C2670C                  JP       NZ,FANDT    ; No - See if DATA stat
 1823 0C55 23                      INC      HL
 1824 0C56 7E                      LD       A,(HL)      ; End of program?
 1825 0C57 23                      INC      HL
 1826 0C58 B6                      OR       (HL)        ; 00 00 Ends program
 1827 0C59 1E06                    LD       E,OD        ; ?OD Error
 1828 0C5B CA0C04                  JP       Z,ERROR     ; Yes - Out of DATA
 1829 0C5E 23                      INC      HL
 1830 0C5F 5E                      LD       E,(HL)      ; LSB of line number
 1831 0C60 23                      INC      HL
 1832 0C61 56                      LD       D,(HL)      ; MSB of line number
 1833 0C62 EB                      EX       DE,HL
 1834 0C63 220E81                  LD       (DATLIN),HL ; Set line of current D
 1835 0C66 EB                      EX       DE,HL
 1836 0C67 CD5008       FANDT:     CALL     GETCHR      ; Get next character
 1837 0C6A FE83                    CP       ZDATA       ; "DATA" token
 1838 0C6C C24E0C                  JP       NZ,FDTLP    ; No "DATA" - Keep look
 1839 0C6F C3E10B                  JP       ANTVLU      ; Found - Convert input
 1840                   ;
 1841 0C72 110000       NEXT:      LD       DE,0        ; In case no index give
 1842 0C75 C4B30E       NEXT1:     CALL     NZ,GETVAR   ; Get index address
 1843 0C78 221381                  LD       (BRKLIN),HL ; Save code string addr
 1844 0C7B CDA103                  CALL     BAKSTK      ; Look for "FOR" block
 1845 0C7E C2FE03                  JP       NZ,NFERR    ; No "FOR" - ?NF Error
 1846 0C81 F9                      LD       SP,HL       ; Clear nested loops
 1847 0C82 D5                      PUSH     DE          ; Save index address
 1848 0C83 7E                      LD       A,(HL)      ; Get sign of STEP
 1849 0C84 23                      INC      HL
 1850 0C85 F5                      PUSH     AF          ; Save sign of STEP
 1851 0C86 D5                      PUSH     DE          ; Save index address
 1852 0C87 CDDD16                  CALL     PHLTFP      ; Move index value to F
 1853 0C8A E3                      EX       (SP),HL     ; Save address of TO va
 1854 0C8B E5                      PUSH     HL          ; Save address of index
 1855 0C8C CD4A14                  CALL     ADDPHL      ; Add STEP to index val
 1856 0C8F E1                      POP      HL          ; Restore address of in
 1857 0C90 CDF716                  CALL     FPTHL       ; Move value to index v
 1858 0C93 E1                      POP      HL          ; Restore address of TO
 1859 0C94 CDEE16                  CALL     LOADFP      ; Move TO value to BCDE
 1860 0C97 E5                      PUSH     HL          ; Save address of line 
 1861 0C98 CD1A17                  CALL     CMPNUM      ; Compare index with TO
 1862 0C9B E1                      POP      HL          ; Restore address of li
 1863 0C9C C1                      POP      BC          ; Address of sign of ST
 1864 0C9D 90                      SUB      B           ; Compare with expected
 1865 0C9E CDEE16                  CALL     LOADFP      ; BC = Loop stmt,DE = L
 1866 0CA1 CAAD0C                  JP       Z,KILFOR    ; Loop finished - Termi
 1867 0CA4 EB                      EX       DE,HL       ; Loop statement line n
 1868 0CA5 22A180                  LD       (LINEAT),HL ; Set loop line number
 1869 0CA8 69                      LD       L,C         ; Set code string to lo
 1870 0CA9 60                      LD       H,B
 1871 0CAA C30C08                  JP       PUTFID      ; Put back "FOR" and co
 1872                   ;
 1873 0CAD F9           KILFOR:    LD       SP,HL       ; Remove "FOR" block
 1874 0CAE 2A1381                  LD       HL,(BRKLIN) ; Code string after "NE
 1875 0CB1 7E                      LD       A,(HL)      ; Get next byte in code
 1876 0CB2 FE2C                    CP       ','         ; More NEXTs ?
 1877 0CB4 C21008                  JP       NZ,RUNCNT   ; No - Do next statemen
 1878 0CB7 CD5008                  CALL     GETCHR      ; Position to index nam
 1879 0CBA CD750C                  CALL     NEXT1       ; Re-enter NEXT routine
 1880                   ; < will not RETurn to here , Exit to RUNCNT or Loop >
 1881                   ;
 1882 0CBD CDCF0C       GETNUM:    CALL     EVAL        ; Get a numeric express
 1883 0CC0 F6           TSTNUM:    DB       0F6H        ; Clear carry (numeric)
 1884 0CC1 37           TSTSTR:    SCF                  ; Set carry (string)
 1885 0CC2 3AF280       CHKTYP:    LD       A,(TYPE)    ; Check types match
 1886 0CC5 8F                      ADC      A,A         ; Expected + actual
 1887 0CC6 B7                      OR       A           ; Clear carry , set par
 1888 0CC7 E8                      RET      PE          ; Even parity - Types m
 1889 0CC8 C30A04                  JP       TMERR       ; Different types - Err
 1890                   ;
 1891 0CCB CDC606       OPNPAR:    CALL     CHKSYN      ; Make sure "(" follows
 1892 0CCE 28                      DB       "("
 1893 0CCF 2B           EVAL:      DEC      HL          ; Evaluate expression &
 1894 0CD0 1600                    LD       D,0         ; Precedence value
 1895 0CD2 D5           EVAL1:     PUSH     DE          ; Save precedence
 1896 0CD3 0E01                    LD       C,1
 1897 0CD5 CDD503                  CALL     CHKSTK      ; Check for 1 level of 
 1898 0CD8 CD460D                  CALL     OPRND       ; Get next expression v
 1899 0CDB 221581       EVAL2:     LD       (NXTOPR),HL ; Save address of next 
 1900 0CDE 2A1581       EVAL3:     LD       HL,(NXTOPR) ; Restore address of ne
 1901 0CE1 C1                      POP      BC          ; Precedence value and 
 1902 0CE2 78                      LD       A,B         ; Get precedence value
 1903 0CE3 FE78                    CP       78H         ; "AND" or "OR" ?
 1904 0CE5 D4C00C                  CALL     NC,TSTNUM   ; No - Make sure it's a
 1905 0CE8 7E                      LD       A,(HL)      ; Get next operator / f
 1906 0CE9 1600                    LD       D,0         ; Clear Last relation
 1907 0CEB D6B3         RLTLP:     SUB      ZGTR        ; ">" Token
 1908 0CED DA070D                  JP       C,FOPRND    ; + - * / ^ AND OR - Te
 1909 0CF0 FE03                    CP       ZLTH+1-ZGTR ; < = >
 1910 0CF2 D2070D                  JP       NC,FOPRND   ; Function - Call it
 1911 0CF5 FE01                    CP       ZEQUAL-ZGTR ; "="
 1912 0CF7 17                      RLA                  ; <- Test for legal
 1913 0CF8 AA                      XOR      D           ; <- combinations of < 
 1914 0CF9 BA                      CP       D           ; <- by combining last 
 1915 0CFA 57                      LD       D,A         ; <- with current one
 1916 0CFB DAF803                  JP       C,SNERR     ; Error if "<<' '==" or
 1917 0CFE 220A81                  LD       (CUROPR),HL ; Save address of curre
 1918 0D01 CD5008                  CALL     GETCHR      ; Get next character
 1919 0D04 C3EB0C                  JP       RLTLP       ; Treat the two as one
 1920                   ;
 1921 0D07 7A           FOPRND:    LD       A,D         ; < = > found ?
 1922 0D08 B7                      OR       A
 1923 0D09 C22E0E                  JP       NZ,TSTRED   ; Yes - Test for reduct
 1924 0D0C 7E                      LD       A,(HL)      ; Get operator token
 1925 0D0D 220A81                  LD       (CUROPR),HL ; Save operator address
 1926 0D10 D6AC                    SUB      ZPLUS       ; Operator or function?
 1927 0D12 D8                      RET      C           ; Neither - Exit
 1928 0D13 FE07                    CP       ZOR+1-ZPLUS ; Is it + - * / ^ AND O
 1929 0D15 D0                      RET      NC          ; No - Exit
 1930 0D16 5F                      LD       E,A         ; Coded operator
 1931 0D17 3AF280                  LD       A,(TYPE)    ; Get data type
 1932 0D1A 3D                      DEC      A           ; FF = numeric , 00 = s
 1933 0D1B B3                      OR       E           ; Combine with coded op
 1934 0D1C 7B                      LD       A,E         ; Get coded operator
 1935 0D1D CA8C12                  JP       Z,CONCAT    ; String concatenation
 1936 0D20 07                      RLCA                 ; Times 2
 1937 0D21 83                      ADD      A,E         ; Times 3
 1938 0D22 5F                      LD       E,A         ; To DE (D is 0)
 1939 0D23 21EA02                  LD       HL,PRITAB   ; Precedence table
 1940 0D26 19                      ADD      HL,DE       ; To the operator conce
 1941 0D27 78                      LD       A,B         ; Last operator precede
 1942 0D28 56                      LD       D,(HL)      ; Get evaluation preced
 1943 0D29 BA                      CP       D           ; Compare with eval pre
 1944 0D2A D0                      RET      NC          ; Exit if higher preced
 1945 0D2B 23                      INC      HL          ; Point to routine addr
 1946 0D2C CDC00C                  CALL     TSTNUM      ; Make sure it's a numb
 1947                   ;
 1948 0D2F C5           STKTHS:    PUSH     BC          ; Save last precedence 
 1949 0D30 01DE0C                  LD       BC,EVAL3    ; Where to go on prec' 
 1950 0D33 C5                      PUSH     BC          ; Save on stack for ret
 1951 0D34 43                      LD       B,E         ; Save operator
 1952 0D35 4A                      LD       C,D         ; Save precedence
 1953 0D36 CDD016                  CALL     STAKFP      ; Move value to stack
 1954 0D39 58                      LD       E,B         ; Restore operator
 1955 0D3A 51                      LD       D,C         ; Restore precedence
 1956 0D3B 4E                      LD       C,(HL)      ; Get LSB of routine ad
 1957 0D3C 23                      INC      HL
 1958 0D3D 46                      LD       B,(HL)      ; Get MSB of routine ad
 1959 0D3E 23                      INC      HL
 1960 0D3F C5                      PUSH     BC          ; Save routine address
 1961 0D40 2A0A81                  LD       HL,(CUROPR) ; Address of current op
 1962 0D43 C3D20C                  JP       EVAL1       ; Loop until prec' brea
 1963                   ;
 1964 0D46 AF           OPRND:     XOR      A           ; Get operand routine
 1965 0D47 32F280                  LD       (TYPE),A    ; Set numeric expected
 1966 0D4A CD5008                  CALL     GETCHR      ; Get next character
 1967 0D4D 1E24                    LD       E,MO        ; ?MO Error
 1968 0D4F CA0C04                  JP       Z,ERROR     ; No operand - Error
 1969 0D52 DAA617                  JP       C,ASCTFP    ; Number - Get value
 1970 0D55 CDEE08                  CALL     CHKLTR      ; See if a letter
 1971 0D58 D2AD0D                  JP       NC,CONVAR   ; Letter - Find variabl
 1972 0D5B FE26                    CP       '&'         ; &H = HEX, &B = BINARY
 1973 0D5D 2012                    JR       NZ, NOTAMP
 1974 0D5F CD5008                  CALL     GETCHR      ; Get next character
 1975 0D62 FE48                    CP       'H'         ; Hex number indicated?
 1976 0D64 CAEA1B                  JP       Z,HEXTFP    ; Convert Hex to FPREG
 1977 0D67 FE42                    CP       'B'         ; Binary number indicat
 1978 0D69 CA5A1C                  JP       Z,BINTFP    ; Convert Bin to FPREG
 1979 0D6C 1E02                    LD       E,SN        ; If neither then a ?SN
 1980 0D6E CA0C04                  JP       Z,ERROR
 1981 0D71 FEAC         NOTAMP:    CP       ZPLUS       ; '+' Token ?
 1982 0D73 CA460D                  JP       Z,OPRND     ; Yes - Look for operan
 1983 0D76 FE2E                    CP       '.'         ; '.' ?
 1984 0D78 CAA617                  JP       Z,ASCTFP    ; Yes - Create FP numbe
 1985 0D7B FEAD                    CP       ZMINUS      ; '-' Token ?
 1986 0D7D CA9C0D                  JP       Z,MINUS     ; Yes - Do minus
 1987 0D80 FE22                    CP       '"'         ; Literal string ?
 1988 0D82 CA5511                  JP       Z,QTSTR     ; Get string terminated
 1989 0D85 FEAA                    CP       ZNOT        ; "NOT" Token ?
 1990 0D87 CA8E0E                  JP       Z,EVNOT     ; Yes - Eval NOT expres
 1991 0D8A FEA7                    CP       ZFN         ; "FN" Token ?
 1992 0D8C CAB910                  JP       Z,DOFN      ; Yes - Do FN routine
 1993 0D8F D6B6                    SUB      ZSGN        ; Is it a function?
 1994 0D91 D2BE0D                  JP       NC,FNOFST   ; Yes - Evaluate functi
 1995 0D94 CDCB0C       EVLPAR:    CALL     OPNPAR      ; Evaluate expression i
 1996 0D97 CDC606                  CALL     CHKSYN      ; Make sure ")" follows
 1997 0D9A 29                      DB       ")"
 1998 0D9B C9                      RET
 1999                   ;
 2000 0D9C 167D         MINUS:     LD       D,7DH       ; '-' precedence
 2001 0D9E CDD20C                  CALL     EVAL1       ; Evaluate until prec' 
 2002 0DA1 2A1581                  LD       HL,(NXTOPR) ; Get next operator add
 2003 0DA4 E5                      PUSH     HL          ; Save next operator ad
 2004 0DA5 CDC816                  CALL     INVSGN      ; Negate value
 2005 0DA8 CDC00C       RETNUM:    CALL     TSTNUM      ; Make sure it's a numb
 2006 0DAB E1                      POP      HL          ; Restore next operator
 2007 0DAC C9                      RET
 2008                   ;
 2009 0DAD CDB30E       CONVAR:    CALL     GETVAR      ; Get variable address 
 2010 0DB0 E5           FRMEVL:    PUSH     HL          ; Save code string addr
 2011 0DB1 EB                      EX       DE,HL       ; Variable address to H
 2012 0DB2 222981                  LD       (FPREG),HL  ; Save address of varia
 2013 0DB5 3AF280                  LD       A,(TYPE)    ; Get type
 2014 0DB8 B7                      OR       A           ; Numeric?
 2015 0DB9 CCDD16                  CALL     Z,PHLTFP    ; Yes - Move contents t
 2016 0DBC E1                      POP      HL          ; Restore code string a
 2017 0DBD C9                      RET
 2018                   ;
 2019 0DBE 0600         FNOFST:    LD       B,0         ; Get address of functi
 2020 0DC0 07                      RLCA                 ; Double function offse
 2021 0DC1 4F                      LD       C,A         ; BC = Offset in functi
 2022 0DC2 C5                      PUSH     BC          ; Save adjusted token v
 2023 0DC3 CD5008                  CALL     GETCHR      ; Get next character
 2024 0DC6 79                      LD       A,C         ; Get adjusted token va
 2025 0DC7 FE31                    CP       2*(ZLEFT-ZSGN)-1 ; Adj' LEFT$,RIGHT
 2026 0DC9 DAE50D                  JP       C,FNVAL     ; No - Do function
 2027 0DCC CDCB0C                  CALL     OPNPAR      ; Evaluate expression  
 2028 0DCF CDC606                  CALL     CHKSYN      ; Make sure ',' follows
 2029 0DD2 2C                      DB       ','
 2030 0DD3 CDC10C                  CALL     TSTSTR      ; Make sure it's a stri
 2031 0DD6 EB                      EX       DE,HL       ; Save code string addr
 2032 0DD7 2A2981                  LD       HL,(FPREG)  ; Get address of string
 2033 0DDA E3                      EX       (SP),HL     ; Save address of strin
 2034 0DDB E5                      PUSH     HL          ; Save adjusted token v
 2035 0DDC EB                      EX       DE,HL       ; Restore code string a
 2036 0DDD CD1E14                  CALL     GETINT      ; Get integer 0-255
 2037 0DE0 EB                      EX       DE,HL       ; Save code string addr
 2038 0DE1 E3                      EX       (SP),HL     ; Save integer,HL = adj
 2039 0DE2 C3ED0D                  JP       GOFUNC      ; Jump to string functi
 2040                   ;
 2041 0DE5 CD940D       FNVAL:     CALL     EVLPAR      ; Evaluate expression
 2042 0DE8 E3                      EX       (SP),HL     ; HL = Adjusted token v
 2043 0DE9 11A80D                  LD       DE,RETNUM   ; Return number from fu
 2044 0DEC D5                      PUSH     DE          ; Save on stack
 2045 0DED 014901       GOFUNC:    LD       BC,FNCTAB   ; Function routine addr
 2046 0DF0 09                      ADD      HL,BC       ; Point to right addres
 2047 0DF1 4E                      LD       C,(HL)      ; Get LSB of address
 2048 0DF2 23                      INC      HL          ;
 2049 0DF3 66                      LD       H,(HL)      ; Get MSB of address
 2050 0DF4 69                      LD       L,C         ; Address to HL
 2051 0DF5 E9                      JP       (HL)        ; Jump to function
 2052                   ;
 2053 0DF6 15           SGNEXP:    DEC      D           ; Dee to flag negative 
 2054 0DF7 FEAD                    CP       ZMINUS      ; '-' token ?
 2055 0DF9 C8                      RET      Z           ; Yes - Return
 2056 0DFA FE2D                    CP       '-'         ; '-' ASCII ?
 2057 0DFC C8                      RET      Z           ; Yes - Return
 2058 0DFD 14                      INC      D           ; Inc to flag positive 
 2059 0DFE FE2B                    CP       '+'         ; '+' ASCII ?
 2060 0E00 C8                      RET      Z           ; Yes - Return
 2061 0E01 FEAC                    CP       ZPLUS       ; '+' token ?
 2062 0E03 C8                      RET      Z           ; Yes - Return
 2063 0E04 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 2064 0E05 C9                      RET                  ; Return "NZ"
 2065                   ;
 2066 0E06 F6           POR:       DB       0F6H        ; Flag "OR"
 2067 0E07 AF           PAND:      XOR      A           ; Flag "AND"
 2068 0E08 F5                      PUSH     AF          ; Save "AND" / "OR" fla
 2069 0E09 CDC00C                  CALL     TSTNUM      ; Make sure it's a numb
 2070 0E0C CD0209                  CALL     DEINT       ; Get integer -32768 to
 2071 0E0F F1                      POP      AF          ; Restore "AND" / "OR" 
 2072 0E10 EB                      EX       DE,HL       ; <- Get last
 2073 0E11 C1                      POP      BC          ; <- value
 2074 0E12 E3                      EX       (SP),HL     ; <- from
 2075 0E13 EB                      EX       DE,HL       ; <- stack
 2076 0E14 CDE016                  CALL     FPBCDE      ; Move last value to FP
 2077 0E17 F5                      PUSH     AF          ; Save "AND" / "OR" fla
 2078 0E18 CD0209                  CALL     DEINT       ; Get integer -32768 to
 2079 0E1B F1                      POP      AF          ; Restore "AND" / "OR" 
 2080 0E1C C1                      POP      BC          ; Get value
 2081 0E1D 79                      LD       A,C         ; Get LSB
 2082 0E1E 217710                  LD       HL,ACPASS   ; Address of save AC as
 2083 0E21 C2290E                  JP       NZ,POR1     ; Jump if OR
 2084 0E24 A3                      AND      E           ; "AND" LSBs
 2085 0E25 4F                      LD       C,A         ; Save LSB
 2086 0E26 78                      LD       A,B         ; Get MBS
 2087 0E27 A2                      AND      D           ; "AND" MSBs
 2088 0E28 E9                      JP       (HL)        ; Save AC as current (A
 2089                   ;
 2090 0E29 B3           POR1:      OR       E           ; "OR" LSBs
 2091 0E2A 4F                      LD       C,A         ; Save LSB
 2092 0E2B 78                      LD       A,B         ; Get MSB
 2093 0E2C B2                      OR       D           ; "OR" MSBs
 2094 0E2D E9                      JP       (HL)        ; Save AC as current (A
 2095                   ;
 2096 0E2E 21400E       TSTRED:    LD       HL,CMPLOG   ; Logical compare routi
 2097 0E31 3AF280                  LD       A,(TYPE)    ; Get data type
 2098 0E34 1F                      RRA                  ; Carry set = string
 2099 0E35 7A                      LD       A,D         ; Get last precedence v
 2100 0E36 17                      RLA                  ; Times 2 plus carry
 2101 0E37 5F                      LD       E,A         ; To E
 2102 0E38 1664                    LD       D,64H       ; Relational precedence
 2103 0E3A 78                      LD       A,B         ; Get current precedenc
 2104 0E3B BA                      CP       D           ; Compare with last
 2105 0E3C D0                      RET      NC          ; Eval if last was rel'
 2106 0E3D C32F0D                  JP       STKTHS      ; Stack this one and ge
 2107                   ;
 2108 0E40 420E         CMPLOG:    DW       CMPLG1      ; Compare two values / 
 2109 0E42 79           CMPLG1:    LD       A,C         ; Get data type
 2110 0E43 B7                      OR       A
 2111 0E44 1F                      RRA
 2112 0E45 C1                      POP      BC          ; Get last expression t
 2113 0E46 D1                      POP      DE
 2114 0E47 F5                      PUSH     AF          ; Save status
 2115 0E48 CDC20C                  CALL     CHKTYP      ; Check that types matc
 2116 0E4B 21840E                  LD       HL,CMPRES   ; Result to comparison
 2117 0E4E E5                      PUSH     HL          ; Save for RETurn
 2118 0E4F CA1A17                  JP       Z,CMPNUM    ; Compare values if num
 2119 0E52 AF                      XOR      A           ; Compare two strings
 2120 0E53 32F280                  LD       (TYPE),A    ; Set type to numeric
 2121 0E56 D5                      PUSH     DE          ; Save string name
 2122 0E57 CDD912                  CALL     GSTRCU      ; Get current string
 2123 0E5A 7E                      LD       A,(HL)      ; Get length of string
 2124 0E5B 23                      INC      HL
 2125 0E5C 23                      INC      HL
 2126 0E5D 4E                      LD       C,(HL)      ; Get LSB of address
 2127 0E5E 23                      INC      HL
 2128 0E5F 46                      LD       B,(HL)      ; Get MSB of address
 2129 0E60 D1                      POP      DE          ; Restore string name
 2130 0E61 C5                      PUSH     BC          ; Save address of strin
 2131 0E62 F5                      PUSH     AF          ; Save length of string
 2132 0E63 CDDD12                  CALL     GSTRDE      ; Get second string
 2133 0E66 CDEE16                  CALL     LOADFP      ; Get address of second
 2134 0E69 F1                      POP      AF          ; Restore length of str
 2135 0E6A 57                      LD       D,A         ; Length to D
 2136 0E6B E1                      POP      HL          ; Restore address of st
 2137 0E6C 7B           CMPSTR:    LD       A,E         ; Bytes of string 2 to 
 2138 0E6D B2                      OR       D           ; Bytes of string 1 to 
 2139 0E6E C8                      RET      Z           ; Exit if all bytes com
 2140 0E6F 7A                      LD       A,D         ; Get bytes of string 1
 2141 0E70 D601                    SUB      1
 2142 0E72 D8                      RET      C           ; Exit if end of string
 2143 0E73 AF                      XOR      A
 2144 0E74 BB                      CP       E           ; Bytes of string 2 to 
 2145 0E75 3C                      INC      A
 2146 0E76 D0                      RET      NC          ; Exit if end of string
 2147 0E77 15                      DEC      D           ; Count bytes in string
 2148 0E78 1D                      DEC      E           ; Count bytes in string
 2149 0E79 0A                      LD       A,(BC)      ; Byte in string 2
 2150 0E7A BE                      CP       (HL)        ; Compare to byte in st
 2151 0E7B 23                      INC      HL          ; Move up string 1
 2152 0E7C 03                      INC      BC          ; Move up string 2
 2153 0E7D CA6C0E                  JP       Z,CMPSTR    ; Same - Try next bytes
 2154 0E80 3F                      CCF                  ; Flag difference (">" 
 2155 0E81 C3AA16                  JP       FLGDIF      ; "<" gives -1 , ">" gi
 2156                   ;
 2157 0E84 3C           CMPRES:    INC      A           ; Increment current val
 2158 0E85 8F                      ADC      A,A         ; Double plus carry
 2159 0E86 C1                      POP      BC          ; Get other value
 2160 0E87 A0                      AND      B           ; Combine them
 2161 0E88 C6FF                    ADD      A,-1        ; Carry set if differen
 2162 0E8A 9F                      SBC      A,A         ; 00 - Equal , FF - Dif
 2163 0E8B C3B116                  JP       FLGREL      ; Set current value & c
 2164                   ;
 2165 0E8E 165A         EVNOT:     LD       D,5AH       ; Precedence value for 
 2166 0E90 CDD20C                  CALL     EVAL1       ; Eval until precedence
 2167 0E93 CDC00C                  CALL     TSTNUM      ; Make sure it's a numb
 2168 0E96 CD0209                  CALL     DEINT       ; Get integer -32768 - 
 2169 0E99 7B                      LD       A,E         ; Get LSB
 2170 0E9A 2F                      CPL                  ; Invert LSB
 2171 0E9B 4F                      LD       C,A         ; Save "NOT" of LSB
 2172 0E9C 7A                      LD       A,D         ; Get MSB
 2173 0E9D 2F                      CPL                  ; Invert MSB
 2174 0E9E CD7710                  CALL     ACPASS      ; Save AC as current
 2175 0EA1 C1                      POP      BC          ; Clean up stack
 2176 0EA2 C3DE0C                  JP       EVAL3       ; Continue evaluation
 2177                   ;
 2178 0EA5 2B           DIMRET:    DEC      HL          ; DEC 'cos GETCHR INCs
 2179 0EA6 CD5008                  CALL     GETCHR      ; Get next character
 2180 0EA9 C8                      RET      Z           ; End of DIM statement
 2181 0EAA CDC606                  CALL     CHKSYN      ; Make sure ',' follows
 2182 0EAD 2C                      DB       ','
 2183 0EAE 01A50E       DIM:       LD       BC,DIMRET   ; Return to "DIMRET"
 2184 0EB1 C5                      PUSH     BC          ; Save on stack
 2185 0EB2 F6                      DB       0F6H        ; Flag "Create" variabl
 2186 0EB3 AF           GETVAR:    XOR      A           ; Find variable address
 2187 0EB4 32F180                  LD       (LCRFLG),A  ; Set locate / create f
 2188 0EB7 46                      LD       B,(HL)      ; Get First byte of nam
 2189 0EB8 CDEE08       GTFNAM:    CALL     CHKLTR      ; See if a letter
 2190 0EBB DAF803                  JP       C,SNERR     ; ?SN Error if not a le
 2191 0EBE AF                      XOR      A
 2192 0EBF 4F                      LD       C,A         ; Clear second byte of 
 2193 0EC0 32F280                  LD       (TYPE),A    ; Set type to numeric
 2194 0EC3 CD5008                  CALL     GETCHR      ; Get next character
 2195 0EC6 DACF0E                  JP       C,SVNAM2    ; Numeric - Save in nam
 2196 0EC9 CDEE08                  CALL     CHKLTR      ; See if a letter
 2197 0ECC DADC0E                  JP       C,CHARTY    ; Not a letter - Check 
 2198 0ECF 4F           SVNAM2:    LD       C,A         ; Save second byte of n
 2199 0ED0 CD5008       ENDNAM:    CALL     GETCHR      ; Get next character
 2200 0ED3 DAD00E                  JP       C,ENDNAM    ; Numeric - Get another
 2201 0ED6 CDEE08                  CALL     CHKLTR      ; See if a letter
 2202 0ED9 D2D00E                  JP       NC,ENDNAM   ; Letter - Get another
 2203 0EDC D624         CHARTY:    SUB      '$'         ; String variable?
 2204 0EDE C2EB0E                  JP       NZ,NOTSTR   ; No - Numeric variable
 2205 0EE1 3C                      INC      A           ; A = 1 (string type)
 2206 0EE2 32F280                  LD       (TYPE),A    ; Set type to string
 2207 0EE5 0F                      RRCA                 ; A = 80H , Flag for st
 2208 0EE6 81                      ADD      A,C         ; 2nd byte of name has 
 2209 0EE7 4F                      LD       C,A         ; Resave second byte on
 2210 0EE8 CD5008                  CALL     GETCHR      ; Get next character
 2211 0EEB 3A1081       NOTSTR:    LD       A,(FORFLG)  ; Array name needed ?
 2212 0EEE 3D                      DEC      A
 2213 0EEF CA980F                  JP       Z,ARLDSV    ; Yes - Get array name
 2214 0EF2 F2FB0E                  JP       P,NSCFOR    ; No array with "FOR" o
 2215 0EF5 7E                      LD       A,(HL)      ; Get byte again
 2216 0EF6 D628                    SUB      '('         ; Subscripted variable?
 2217 0EF8 CA700F                  JP       Z,SBSCPT    ; Yes - Sort out subscr
 2218                   ;
 2219 0EFB AF           NSCFOR:    XOR      A           ; Simple variable
 2220 0EFC 321081                  LD       (FORFLG),A  ; Clear "FOR" flag
 2221 0EFF E5                      PUSH     HL          ; Save code string addr
 2222 0F00 50                      LD       D,B         ; DE = Variable name to
 2223 0F01 59                      LD       E,C
 2224 0F02 2A2381                  LD       HL,(FNRGNM) ; FN argument name
 2225 0F05 CDC006                  CALL     CPDEHL      ; Is it the FN argument
 2226 0F08 112581                  LD       DE,FNARG    ; Point to argument val
 2227 0F0B CAE015                  JP       Z,POPHRT    ; Yes - Return FN argum
 2228 0F0E 2A1D81                  LD       HL,(VAREND) ; End of variables
 2229 0F11 EB                      EX       DE,HL       ; Address of end of sea
 2230 0F12 2A1B81                  LD       HL,(PROGND) ; Start of variables ad
 2231 0F15 CDC006       FNDVAR:    CALL     CPDEHL      ; End of variable list 
 2232 0F18 CA2E0F                  JP       Z,CFEVAL    ; Yes - Called from EVA
 2233 0F1B 79                      LD       A,C         ; Get second byte of na
 2234 0F1C 96                      SUB      (HL)        ; Compare with name in 
 2235 0F1D 23                      INC      HL          ; Move on to first byte
 2236 0F1E C2230F                  JP       NZ,FNTHR    ; Different - Find anot
 2237 0F21 78                      LD       A,B         ; Get first byte of nam
 2238 0F22 96                      SUB      (HL)        ; Compare with name in 
 2239 0F23 23           FNTHR:     INC      HL          ; Move on to LSB of val
 2240 0F24 CA620F                  JP       Z,RETADR    ; Found - Return addres
 2241 0F27 23                      INC      HL          ; <- Skip
 2242 0F28 23                      INC      HL          ; <- over
 2243 0F29 23                      INC      HL          ; <- F.P.
 2244 0F2A 23                      INC      HL          ; <- value
 2245 0F2B C3150F                  JP       FNDVAR      ; Keep looking
 2246                   ;
 2247 0F2E E1           CFEVAL:    POP      HL          ; Restore code string a
 2248 0F2F E3                      EX       (SP),HL     ; Get return address
 2249 0F30 D5                      PUSH     DE          ; Save address of varia
 2250 0F31 11B00D                  LD       DE,FRMEVL   ; Return address in EVA
 2251 0F34 CDC006                  CALL     CPDEHL      ; Called from EVAL ?
 2252 0F37 D1                      POP      DE          ; Restore address of va
 2253 0F38 CA650F                  JP       Z,RETNUL    ; Yes - Return null var
 2254 0F3B E3                      EX       (SP),HL     ; Put back return
 2255 0F3C E5                      PUSH     HL          ; Save code string addr
 2256 0F3D C5                      PUSH     BC          ; Save variable name
 2257 0F3E 010600                  LD       BC,6        ; 2 byte name plus 4 by
 2258 0F41 2A1F81                  LD       HL,(ARREND) ; End of arrays
 2259 0F44 E5                      PUSH     HL          ; Save end of arrays
 2260 0F45 09                      ADD      HL,BC       ; Move up 6 bytes
 2261 0F46 C1                      POP      BC          ; Source address in BC
 2262 0F47 E5                      PUSH     HL          ; Save new end address
 2263 0F48 CDC403                  CALL     MOVUP       ; Move arrays up
 2264 0F4B E1                      POP      HL          ; Restore new end addre
 2265 0F4C 221F81                  LD       (ARREND),HL ; Set new end address
 2266 0F4F 60                      LD       H,B         ; End of variables to H
 2267 0F50 69                      LD       L,C
 2268 0F51 221D81                  LD       (VAREND),HL ; Set new end address
 2269                   ;
 2270 0F54 2B           ZEROLP:    DEC      HL          ; Back through to zero 
 2271 0F55 3600                    LD       (HL),0      ; Zero byte in variable
 2272 0F57 CDC006                  CALL     CPDEHL      ; Done them all?
 2273 0F5A C2540F                  JP       NZ,ZEROLP   ; No - Keep on going
 2274 0F5D D1                      POP      DE          ; Get variable name
 2275 0F5E 73                      LD       (HL),E      ; Store second characte
 2276 0F5F 23                      INC      HL
 2277 0F60 72                      LD       (HL),D      ; Store first character
 2278 0F61 23                      INC      HL
 2279 0F62 EB           RETADR:    EX       DE,HL       ; Address of variable i
 2280 0F63 E1                      POP      HL          ; Restore code string a
 2281 0F64 C9                      RET
 2282                   ;
 2283 0F65 322C81       RETNUL:    LD       (FPEXP),A   ; Set result to zero
 2284 0F68 219403                  LD       HL,ZERBYT   ; Also set a null strin
 2285 0F6B 222981                  LD       (FPREG),HL  ; Save for EVAL
 2286 0F6E E1                      POP      HL          ; Restore code string a
 2287 0F6F C9                      RET
 2288                   ;
 2289 0F70 E5           SBSCPT:    PUSH     HL          ; Save code string addr
 2290 0F71 2AF180                  LD       HL,(LCRFLG) ; Locate/Create and Typ
 2291 0F74 E3                      EX       (SP),HL     ; Save and get code str
 2292 0F75 57                      LD       D,A         ; Zero number of dimens
 2293 0F76 D5           SCPTLP:    PUSH     DE          ; Save number of dimens
 2294 0F77 C5                      PUSH     BC          ; Save array name
 2295 0F78 CDF608                  CALL     FPSINT      ; Get subscript (0-3276
 2296 0F7B C1                      POP      BC          ; Restore array name
 2297 0F7C F1                      POP      AF          ; Get number of dimensi
 2298 0F7D EB                      EX       DE,HL
 2299 0F7E E3                      EX       (SP),HL     ; Save subscript value
 2300 0F7F E5                      PUSH     HL          ; Save LCRFLG and TYPE
 2301 0F80 EB                      EX       DE,HL
 2302 0F81 3C                      INC      A           ; Count dimensions
 2303 0F82 57                      LD       D,A         ; Save in D
 2304 0F83 7E                      LD       A,(HL)      ; Get next byte in code
 2305 0F84 FE2C                    CP       ','         ; Comma (more to come)?
 2306 0F86 CA760F                  JP       Z,SCPTLP    ; Yes - More subscripts
 2307 0F89 CDC606                  CALL     CHKSYN      ; Make sure ")" follows
 2308 0F8C 29                      DB       ")"
 2309 0F8D 221581                  LD       (NXTOPR),HL ; Save code string addr
 2310 0F90 E1                      POP      HL          ; Get LCRFLG and TYPE
 2311 0F91 22F180                  LD       (LCRFLG),HL ; Restore Locate/create
 2312 0F94 1E00                    LD       E,0         ; Flag not CSAVE* or CL
 2313 0F96 D5                      PUSH     DE          ; Save number of dimens
 2314 0F97 11                      DB       11H         ; Skip "PUSH HL" and "P
 2315                   ;
 2316 0F98 E5           ARLDSV:    PUSH     HL          ; Save code string addr
 2317 0F99 F5                      PUSH     AF          ; A = 00 , Flags set = 
 2318 0F9A 2A1D81                  LD       HL,(VAREND) ; Start of arrays
 2319 0F9D 3E                      DB       3EH         ; Skip "ADD HL,DE"
 2320 0F9E 19           FNDARY:    ADD      HL,DE       ; Move to next array st
 2321 0F9F EB                      EX       DE,HL
 2322 0FA0 2A1F81                  LD       HL,(ARREND) ; End of arrays
 2323 0FA3 EB                      EX       DE,HL       ; Current array pointer
 2324 0FA4 CDC006                  CALL     CPDEHL      ; End of arrays found?
 2325 0FA7 CAD00F                  JP       Z,CREARY    ; Yes - Create array
 2326 0FAA 7E                      LD       A,(HL)      ; Get second byte of na
 2327 0FAB B9                      CP       C           ; Compare with name giv
 2328 0FAC 23                      INC      HL          ; Move on
 2329 0FAD C2B20F                  JP       NZ,NXTARY   ; Different - Find next
 2330 0FB0 7E                      LD       A,(HL)      ; Get first byte of nam
 2331 0FB1 B8                      CP       B           ; Compare with name giv
 2332 0FB2 23           NXTARY:    INC      HL          ; Move on
 2333 0FB3 5E                      LD       E,(HL)      ; Get LSB of next array
 2334 0FB4 23                      INC      HL
 2335 0FB5 56                      LD       D,(HL)      ; Get MSB of next array
 2336 0FB6 23                      INC      HL
 2337 0FB7 C29E0F                  JP       NZ,FNDARY   ; Not found - Keep look
 2338 0FBA 3AF180                  LD       A,(LCRFLG)  ; Found Locate or Creat
 2339 0FBD B7                      OR       A
 2340 0FBE C20104                  JP       NZ,DDERR    ; Create - ?DD Error
 2341 0FC1 F1                      POP      AF          ; Locate - Get number o
 2342 0FC2 44                      LD       B,H         ; BC Points to array di
 2343 0FC3 4D                      LD       C,L
 2344 0FC4 CAE015                  JP       Z,POPHRT    ; Jump if array load/sa
 2345 0FC7 96                      SUB      (HL)        ; Same number of dimens
 2346 0FC8 CA2E10                  JP       Z,FINDEL    ; Yes - Find element
 2347 0FCB 1E10         BSERR:     LD       E,BS        ; ?BS Error
 2348 0FCD C30C04                  JP       ERROR       ; Output error
 2349                   ;
 2350 0FD0 110400       CREARY:    LD       DE,4        ; 4 Bytes per entry
 2351 0FD3 F1                      POP      AF          ; Array to save or 0 di
 2352 0FD4 CA1709                  JP       Z,FCERR     ; Yes - ?FC Error
 2353 0FD7 71                      LD       (HL),C      ; Save second byte of n
 2354 0FD8 23                      INC      HL
 2355 0FD9 70                      LD       (HL),B      ; Save first byte of na
 2356 0FDA 23                      INC      HL
 2357 0FDB 4F                      LD       C,A         ; Number of dimensions 
 2358 0FDC CDD503                  CALL     CHKSTK      ; Check if enough memor
 2359 0FDF 23                      INC      HL          ; Point to number of di
 2360 0FE0 23                      INC      HL
 2361 0FE1 220A81                  LD       (CUROPR),HL ; Save address of point
 2362 0FE4 71                      LD       (HL),C      ; Set number of dimensi
 2363 0FE5 23                      INC      HL
 2364 0FE6 3AF180                  LD       A,(LCRFLG)  ; Locate of Create?
 2365 0FE9 17                      RLA                  ; Carry set = Create
 2366 0FEA 79                      LD       A,C         ; Get number of dimensi
 2367 0FEB 010B00       CRARLP:    LD       BC,10+1     ; Default dimension siz
 2368 0FEE D2F30F                  JP       NC,DEFSIZ   ; Locate - Set default 
 2369 0FF1 C1                      POP      BC          ; Get specified dimensi
 2370 0FF2 03                      INC      BC          ; Include zero element
 2371 0FF3 71           DEFSIZ:    LD       (HL),C      ; Save LSB of dimension
 2372 0FF4 23                      INC      HL
 2373 0FF5 70                      LD       (HL),B      ; Save MSB of dimension
 2374 0FF6 23                      INC      HL
 2375 0FF7 F5                      PUSH     AF          ; Save num' of dim'ns a
 2376 0FF8 E5                      PUSH     HL          ; Save address of dim'n
 2377 0FF9 CD8B17                  CALL     MLDEBC      ; Multiply DE by BC to 
 2378 0FFC EB                      EX       DE,HL       ; amount of mem needed 
 2379 0FFD E1                      POP      HL          ; Restore address of di
 2380 0FFE F1                      POP      AF          ; Restore number of dim
 2381 0FFF 3D                      DEC      A           ; Count them
 2382 1000 C2EB0F                  JP       NZ,CRARLP   ; Do next dimension if 
 2383 1003 F5                      PUSH     AF          ; Save locate/create fl
 2384 1004 42                      LD       B,D         ; MSB of memory needed
 2385 1005 4B                      LD       C,E         ; LSB of memory needed
 2386 1006 EB                      EX       DE,HL
 2387 1007 19                      ADD      HL,DE       ; Add bytes to array st
 2388 1008 DAED03                  JP       C,OMERR     ; Too big - Error
 2389 100B CDDE03                  CALL     ENFMEM      ; See if enough memory
 2390 100E 221F81                  LD       (ARREND),HL ; Save new end of array
 2391                   ;
 2392 1011 2B           ZERARY:    DEC      HL          ; Back through array da
 2393 1012 3600                    LD       (HL),0      ; Set array element to 
 2394 1014 CDC006                  CALL     CPDEHL      ; All elements zeroed?
 2395 1017 C21110                  JP       NZ,ZERARY   ; No - Keep on going
 2396 101A 03                      INC      BC          ; Number of bytes + 1
 2397 101B 57                      LD       D,A         ; A=0
 2398 101C 2A0A81                  LD       HL,(CUROPR) ; Get address of array
 2399 101F 5E                      LD       E,(HL)      ; Number of dimensions
 2400 1020 EB                      EX       DE,HL       ; To HL
 2401 1021 29                      ADD      HL,HL       ; Two bytes per dimensi
 2402 1022 09                      ADD      HL,BC       ; Add number of bytes
 2403 1023 EB                      EX       DE,HL       ; Bytes needed to DE
 2404 1024 2B                      DEC      HL
 2405 1025 2B                      DEC      HL
 2406 1026 73                      LD       (HL),E      ; Save LSB of bytes nee
 2407 1027 23                      INC      HL
 2408 1028 72                      LD       (HL),D      ; Save MSB of bytes nee
 2409 1029 23                      INC      HL
 2410 102A F1                      POP      AF          ; Locate / Create?
 2411 102B DA5210                  JP       C,ENDDIM    ; A is 0 , End if creat
 2412 102E 47           FINDEL:    LD       B,A         ; Find array element
 2413 102F 4F                      LD       C,A
 2414 1030 7E                      LD       A,(HL)      ; Number of dimensions
 2415 1031 23                      INC      HL
 2416 1032 16                      DB       16H         ; Skip "POP HL"
 2417 1033 E1           FNDELP:    POP      HL          ; Address of next dim' 
 2418 1034 5E                      LD       E,(HL)      ; Get LSB of dim'n size
 2419 1035 23                      INC      HL
 2420 1036 56                      LD       D,(HL)      ; Get MSB of dim'n size
 2421 1037 23                      INC      HL
 2422 1038 E3                      EX       (SP),HL     ; Save address - Get in
 2423 1039 F5                      PUSH     AF          ; Save number of dim'ns
 2424 103A CDC006                  CALL     CPDEHL      ; Dimension too large?
 2425 103D D2CB0F                  JP       NC,BSERR    ; Yes - ?BS Error
 2426 1040 E5                      PUSH     HL          ; Save index
 2427 1041 CD8B17                  CALL     MLDEBC      ; Multiply previous by 
 2428 1044 D1                      POP      DE          ; Index supplied to DE
 2429 1045 19                      ADD      HL,DE       ; Add index to pointer
 2430 1046 F1                      POP      AF          ; Number of dimensions
 2431 1047 3D                      DEC      A           ; Count them
 2432 1048 44                      LD       B,H         ; MSB of pointer
 2433 1049 4D                      LD       C,L         ; LSB of pointer
 2434 104A C23310                  JP       NZ,FNDELP   ; More - Keep going
 2435 104D 29                      ADD      HL,HL       ; 4 Bytes per element
 2436 104E 29                      ADD      HL,HL
 2437 104F C1                      POP      BC          ; Start of array
 2438 1050 09                      ADD      HL,BC       ; Point to element
 2439 1051 EB                      EX       DE,HL       ; Address of element to
 2440 1052 2A1581       ENDDIM:    LD       HL,(NXTOPR) ; Got code string addre
 2441 1055 C9                      RET
 2442                   ;
 2443 1056 2A1F81       FRE:       LD       HL,(ARREND) ; Start of free memory
 2444 1059 EB                      EX       DE,HL       ; To DE
 2445 105A 210000                  LD       HL,0        ; End of free memory
 2446 105D 39                      ADD      HL,SP       ; Current stack value
 2447 105E 3AF280                  LD       A,(TYPE)    ; Dummy argument type
 2448 1061 B7                      OR       A
 2449 1062 CA7210                  JP       Z,FRENUM    ; Numeric - Free variab
 2450 1065 CDD912                  CALL     GSTRCU      ; Current string to poo
 2451 1068 CDD911                  CALL     GARBGE      ; Garbage collection
 2452 106B 2A9F80                  LD       HL,(STRSPC) ; Bottom of string spac
 2453 106E EB                      EX       DE,HL       ; To DE
 2454 106F 2A0881                  LD       HL,(STRBOT) ; Bottom of string spac
 2455 1072 7D           FRENUM:    LD       A,L         ; Get LSB of end
 2456 1073 93                      SUB      E           ; Subtract LSB of begin
 2457 1074 4F                      LD       C,A         ; Save difference if C
 2458 1075 7C                      LD       A,H         ; Get MSB of end
 2459 1076 9A                      SBC      A,D         ; Subtract MSB of begin
 2460 1077 41           ACPASS:    LD       B,C         ; Return integer AC
 2461 1078 50           ABPASS:    LD       D,B         ; Return integer AB
 2462 1079 1E00                    LD       E,0
 2463 107B 21F280                  LD       HL,TYPE     ; Point to type
 2464 107E 73                      LD       (HL),E      ; Set type to numeric
 2465 107F 0690                    LD       B,80H+16    ; 16 bit integer
 2466 1081 C3B616                  JP       RETINT      ; Return the integr
 2467                   ;
 2468 1084 3AF080       POS:       LD       A,(CURPOS)  ; Get cursor position
 2469 1087 47           PASSA:     LD       B,A         ; Put A into AB
 2470 1088 AF                      XOR      A           ; Zero A
 2471 1089 C37810                  JP       ABPASS      ; Return integer AB
 2472                   ;
 2473 108C CD0F11       DEF:       CALL     CHEKFN      ; Get "FN" and name
 2474 108F CD0111                  CALL     IDTEST      ; Test for illegal dire
 2475 1092 01E709                  LD       BC,DATA     ; To get next statement
 2476 1095 C5                      PUSH     BC          ; Save address for RETu
 2477 1096 D5                      PUSH     DE          ; Save address of funct
 2478 1097 CDC606                  CALL     CHKSYN      ; Make sure "(" follows
 2479 109A 28                      DB       "("
 2480 109B CDB30E                  CALL     GETVAR      ; Get argument variable
 2481 109E E5                      PUSH     HL          ; Save code string addr
 2482 109F EB                      EX       DE,HL       ; Argument address to H
 2483 10A0 2B                      DEC      HL
 2484 10A1 56                      LD       D,(HL)      ; Get first byte of arg
 2485 10A2 2B                      DEC      HL
 2486 10A3 5E                      LD       E,(HL)      ; Get second byte of ar
 2487 10A4 E1                      POP      HL          ; Restore code string a
 2488 10A5 CDC00C                  CALL     TSTNUM      ; Make sure numeric arg
 2489 10A8 CDC606                  CALL     CHKSYN      ; Make sure ")" follows
 2490 10AB 29                      DB       ")"
 2491 10AC CDC606                  CALL     CHKSYN      ; Make sure "=" follows
 2492 10AF B4                      DB       ZEQUAL      ; "=" token
 2493 10B0 44                      LD       B,H         ; Code string address t
 2494 10B1 4D                      LD       C,L
 2495 10B2 E3                      EX       (SP),HL     ; Save code str , Get F
 2496 10B3 71                      LD       (HL),C      ; Save LSB of FN code s
 2497 10B4 23                      INC      HL
 2498 10B5 70                      LD       (HL),B      ; Save MSB of FN code s
 2499 10B6 C34E11                  JP       SVSTAD      ; Save address and do f
 2500                   ;
 2501 10B9 CD0F11       DOFN:      CALL     CHEKFN      ; Make sure FN follows
 2502 10BC D5                      PUSH     DE          ; Save function pointer
 2503 10BD CD940D                  CALL     EVLPAR      ; Evaluate expression i
 2504 10C0 CDC00C                  CALL     TSTNUM      ; Make sure numeric res
 2505 10C3 E3                      EX       (SP),HL     ; Save code str , Get F
 2506 10C4 5E                      LD       E,(HL)      ; Get LSB of FN code st
 2507 10C5 23                      INC      HL
 2508 10C6 56                      LD       D,(HL)      ; Get MSB of FN code st
 2509 10C7 23                      INC      HL
 2510 10C8 7A                      LD       A,D         ; And function DEFined?
 2511 10C9 B3                      OR       E
 2512 10CA CA0404                  JP       Z,UFERR     ; No - ?UF Error
 2513 10CD 7E                      LD       A,(HL)      ; Get LSB of argument a
 2514 10CE 23                      INC      HL
 2515 10CF 66                      LD       H,(HL)      ; Get MSB of argument a
 2516 10D0 6F                      LD       L,A         ; HL = Arg variable add
 2517 10D1 E5                      PUSH     HL          ; Save it
 2518 10D2 2A2381                  LD       HL,(FNRGNM) ; Get old argument name
 2519 10D5 E3                      EX       (SP),HL     ;        ; Save old , G
 2520 10D6 222381                  LD       (FNRGNM),HL ; Set new argument name
 2521 10D9 2A2781                  LD       HL,(FNARG+2) ; Get LSB,NLSB of old 
 2522 10DC E5                      PUSH     HL          ; Save it
 2523 10DD 2A2581                  LD       HL,(FNARG)  ; Get MSB,EXP of old ar
 2524 10E0 E5                      PUSH     HL          ; Save it
 2525 10E1 212581                  LD       HL,FNARG    ; HL = Value of argumen
 2526 10E4 D5                      PUSH     DE          ; Save FN code string a
 2527 10E5 CDF716                  CALL     FPTHL       ; Move FPREG to argumen
 2528 10E8 E1                      POP      HL          ; Get FN code string ad
 2529 10E9 CDBD0C                  CALL     GETNUM      ; Get value from functi
 2530 10EC 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 2531 10ED CD5008                  CALL     GETCHR      ; Get next character
 2532 10F0 C2F803                  JP       NZ,SNERR    ; Bad character in FN -
 2533 10F3 E1                      POP      HL          ; Get MSB,EXP of old ar
 2534 10F4 222581                  LD       (FNARG),HL  ; Restore it
 2535 10F7 E1                      POP      HL          ; Get LSB,NLSB of old a
 2536 10F8 222781                  LD       (FNARG+2),HL ; Restore it
 2537 10FB E1                      POP      HL          ; Get name of old arg
 2538 10FC 222381                  LD       (FNRGNM),HL ; Restore it
 2539 10FF E1                      POP      HL          ; Restore code string a
 2540 1100 C9                      RET
 2541                   ;
 2542 1101 E5           IDTEST:    PUSH     HL          ; Save code string addr
 2543 1102 2AA180                  LD       HL,(LINEAT) ; Get current line numb
 2544 1105 23                      INC      HL          ; -1 means direct state
 2545 1106 7C                      LD       A,H
 2546 1107 B5                      OR       L
 2547 1108 E1                      POP      HL          ; Restore code string a
 2548 1109 C0                      RET      NZ          ; Return if in program
 2549 110A 1E16                    LD       E,ID        ; ?ID Error
 2550 110C C30C04                  JP       ERROR
 2551                   ;
 2552 110F CDC606       CHEKFN:    CALL     CHKSYN      ; Make sure FN follows
 2553 1112 A7                      DB       ZFN         ; "FN" token
 2554 1113 3E80                    LD       A,80H
 2555 1115 321081                  LD       (FORFLG),A  ; Flag FN name to find
 2556 1118 B6                      OR       (HL)        ; FN name has bit 7 set
 2557 1119 47                      LD       B,A         ; in first byte of name
 2558 111A CDB80E                  CALL     GTFNAM      ; Get FN name
 2559 111D C3C00C                  JP       TSTNUM      ; Make sure numeric fun
 2560                   ;
 2561 1120 CDC00C       STR:       CALL     TSTNUM      ; Make sure it's a numb
 2562 1123 CD4418                  CALL     NUMASC      ; Turn number into text
 2563 1126 CD5411       STR1:      CALL     CRTST       ; Create string entry f
 2564 1129 CDD912                  CALL     GSTRCU      ; Current string to poo
 2565 112C 013413                  LD       BC,TOPOOL   ; Save in string pool
 2566 112F C5                      PUSH     BC          ; Save address on stack
 2567                   ;
 2568 1130 7E           SAVSTR:    LD       A,(HL)      ; Get string length
 2569 1131 23                      INC      HL
 2570 1132 23                      INC      HL
 2571 1133 E5                      PUSH     HL          ; Save pointer to strin
 2572 1134 CDAF11                  CALL     TESTR       ; See if enough string 
 2573 1137 E1                      POP      HL          ; Restore pointer to st
 2574 1138 4E                      LD       C,(HL)      ; Get LSB of address
 2575 1139 23                      INC      HL
 2576 113A 46                      LD       B,(HL)      ; Get MSB of address
 2577 113B CD4811                  CALL     CRTMST      ; Create string entry
 2578 113E E5                      PUSH     HL          ; Save pointer to MSB o
 2579 113F 6F                      LD       L,A         ; Length of string
 2580 1140 CDCC12                  CALL     TOSTRA      ; Move to string area
 2581 1143 D1                      POP      DE          ; Restore pointer to MS
 2582 1144 C9                      RET
 2583                   ;
 2584 1145 CDAF11       MKTMST:    CALL     TESTR       ; See if enough string 
 2585 1148 210481       CRTMST:    LD       HL,TMPSTR   ; Temporary string
 2586 114B E5                      PUSH     HL          ; Save it
 2587 114C 77                      LD       (HL),A      ; Save length of string
 2588 114D 23                      INC      HL
 2589 114E 23           SVSTAD:    INC      HL
 2590 114F 73                      LD       (HL),E      ; Save LSB of address
 2591 1150 23                      INC      HL
 2592 1151 72                      LD       (HL),D      ; Save MSB of address
 2593 1152 E1                      POP      HL          ; Restore pointer
 2594 1153 C9                      RET
 2595                   ;
 2596 1154 2B           CRTST:     DEC      HL          ; DEC - INCed after
 2597 1155 0622         QTSTR:     LD       B,'"'       ; Terminating quote
 2598 1157 50                      LD       D,B         ; Quote to D
 2599 1158 E5           DTSTR:     PUSH     HL          ; Save start
 2600 1159 0EFF                    LD       C,-1        ; Set counter to -1
 2601 115B 23           QTSTLP:    INC      HL          ; Move on
 2602 115C 7E                      LD       A,(HL)      ; Get byte
 2603 115D 0C                      INC      C           ; Count bytes
 2604 115E B7                      OR       A           ; End of line?
 2605 115F CA6A11                  JP       Z,CRTSTE    ; Yes - Create string e
 2606 1162 BA                      CP       D           ; Terminator D found?
 2607 1163 CA6A11                  JP       Z,CRTSTE    ; Yes - Create string e
 2608 1166 B8                      CP       B           ; Terminator B found?
 2609 1167 C25B11                  JP       NZ,QTSTLP   ; No - Keep looking
 2610 116A FE22         CRTSTE:    CP       '"'         ; End with '"'?
 2611 116C CC5008                  CALL     Z,GETCHR    ; Yes - Get next charac
 2612 116F E3                      EX       (SP),HL     ; Starting quote
 2613 1170 23                      INC      HL          ; First byte of string
 2614 1171 EB                      EX       DE,HL       ; To DE
 2615 1172 79                      LD       A,C         ; Get length
 2616 1173 CD4811                  CALL     CRTMST      ; Create string entry
 2617 1176 110481       TSTOPL:    LD       DE,TMPSTR   ; Temporary string
 2618 1179 2AF680                  LD       HL,(TMSTPT) ; Temporary string pool
 2619 117C 222981                  LD       (FPREG),HL  ; Save address of strin
 2620 117F 3E01                    LD       A,1
 2621 1181 32F280                  LD       (TYPE),A    ; Set type to string
 2622 1184 CDFA16                  CALL     DETHL4      ; Move string to pool
 2623 1187 CDC006                  CALL     CPDEHL      ; Out of string pool?
 2624 118A 22F680                  LD       (TMSTPT),HL ; Save new pointer
 2625 118D E1                      POP      HL          ; Restore code string a
 2626 118E 7E                      LD       A,(HL)      ; Get next code byte
 2627 118F C0                      RET      NZ          ; Return if pool OK
 2628 1190 1E1E                    LD       E,ST        ; ?ST Error
 2629 1192 C30C04                  JP       ERROR       ; String pool overflow
 2630                   ;
 2631 1195 23           PRNUMS:    INC      HL          ; Skip leading space
 2632 1196 CD5411       PRS:       CALL     CRTST       ; Create string entry f
 2633 1199 CDD912       PRS1:      CALL     GSTRCU      ; Current string to poo
 2634 119C CDEE16                  CALL     LOADFP      ; Move string block to 
 2635 119F 1C                      INC      E           ; Length + 1
 2636 11A0 1D           PRSLP:     DEC      E           ; Count characters
 2637 11A1 C8                      RET      Z           ; End of string
 2638 11A2 0A                      LD       A,(BC)      ; Get byte to output
 2639 11A3 CDD106                  CALL     OUTC        ; Output character in A
 2640 11A6 FE0D                    CP       CR          ; Return?
 2641 11A8 CC020B                  CALL     Z,DONULL    ; Yes - Do nulls
 2642 11AB 03                      INC      BC          ; Next byte in string
 2643 11AC C3A011                  JP       PRSLP       ; More characters to ou
 2644                   ;
 2645 11AF B7           TESTR:     OR       A           ; Test if enough room
 2646 11B0 0E                      DB       0EH         ; No garbage collection
 2647 11B1 F1           GRBDON:    POP      AF          ; Garbage collection do
 2648 11B2 F5                      PUSH     AF          ; Save status
 2649 11B3 2A9F80                  LD       HL,(STRSPC) ; Bottom of string spac
 2650 11B6 EB                      EX       DE,HL       ; To DE
 2651 11B7 2A0881                  LD       HL,(STRBOT) ; Bottom of string area
 2652 11BA 2F                      CPL                  ; Negate length (Top do
 2653 11BB 4F                      LD       C,A         ; -Length to BC
 2654 11BC 06FF                    LD       B,-1        ; BC = -ve length of st
 2655 11BE 09                      ADD      HL,BC       ; Add to bottom of spac
 2656 11BF 23                      INC      HL          ; Plus one for 2's comp
 2657 11C0 CDC006                  CALL     CPDEHL      ; Below string RAM area
 2658 11C3 DACD11                  JP       C,TESTOS    ; Tidy up if not done e
 2659 11C6 220881                  LD       (STRBOT),HL ; Save new bottom of ar
 2660 11C9 23                      INC      HL          ; Point to first byte o
 2661 11CA EB                      EX       DE,HL       ; Address to DE
 2662 11CB F1           POPAF:     POP      AF          ; Throw away status pus
 2663 11CC C9                      RET
 2664                   ;
 2665 11CD F1           TESTOS:    POP      AF          ; Garbage collect been 
 2666 11CE 1E1A                    LD       E,OS        ; ?OS Error
 2667 11D0 CA0C04                  JP       Z,ERROR     ; Yes - Not enough stri
 2668 11D3 BF                      CP       A           ; Flag garbage collect 
 2669 11D4 F5                      PUSH     AF          ; Save status
 2670 11D5 01B111                  LD       BC,GRBDON   ; Garbage collection do
 2671 11D8 C5                      PUSH     BC          ; Save for RETurn
 2672 11D9 2AF480       GARBGE:    LD       HL,(LSTRAM) ; Get end of RAM pointe
 2673 11DC 220881       GARBLP:    LD       (STRBOT),HL ; Reset string pointer
 2674 11DF 210000                  LD       HL,0
 2675 11E2 E5                      PUSH     HL          ; Flag no string found
 2676 11E3 2A9F80                  LD       HL,(STRSPC) ; Get bottom of string 
 2677 11E6 E5                      PUSH     HL          ; Save bottom of string
 2678 11E7 21F880                  LD       HL,TMSTPL   ; Temporary string pool
 2679 11EA EB           GRBLP:     EX       DE,HL
 2680 11EB 2AF680                  LD       HL,(TMSTPT) ; Temporary string pool
 2681 11EE EB                      EX       DE,HL
 2682 11EF CDC006                  CALL     CPDEHL      ; Temporary string pool
 2683 11F2 01EA11                  LD       BC,GRBLP    ; Loop until string poo
 2684 11F5 C23E12                  JP       NZ,STPOOL   ; No - See if in string
 2685 11F8 2A1B81                  LD       HL,(PROGND) ; Start of simple varia
 2686 11FB EB           SMPVAR:    EX       DE,HL
 2687 11FC 2A1D81                  LD       HL,(VAREND) ; End of simple variabl
 2688 11FF EB                      EX       DE,HL
 2689 1200 CDC006                  CALL     CPDEHL      ; All simple strings do
 2690 1203 CA1112                  JP       Z,ARRLP     ; Yes - Do string array
 2691 1206 7E                      LD       A,(HL)      ; Get type of variable
 2692 1207 23                      INC      HL
 2693 1208 23                      INC      HL
 2694 1209 B7                      OR       A           ; "S" flag set if strin
 2695 120A CD4112                  CALL     STRADD      ; See if string in stri
 2696 120D C3FB11                  JP       SMPVAR      ; Loop until simple one
 2697                   ;
 2698 1210 C1           GNXARY:    POP      BC          ; Scrap address of this
 2699 1211 EB           ARRLP:     EX       DE,HL
 2700 1212 2A1F81                  LD       HL,(ARREND) ; End of string arrays
 2701 1215 EB                      EX       DE,HL
 2702 1216 CDC006                  CALL     CPDEHL      ; All string arrays don
 2703 1219 CA6712                  JP       Z,SCNEND    ; Yes - Move string if 
 2704 121C CDEE16                  CALL     LOADFP      ; Get array name to BCD
 2705 121F 7B                      LD       A,E         ; Get type of array
 2706 1220 E5                      PUSH     HL          ; Save address of num o
 2707 1221 09                      ADD      HL,BC       ; Start of next array
 2708 1222 B7                      OR       A           ; Test type of array
 2709 1223 F21012                  JP       P,GNXARY    ; Numeric array - Ignor
 2710 1226 220A81                  LD       (CUROPR),HL ; Save address of next 
 2711 1229 E1                      POP      HL          ; Get address of num of
 2712 122A 4E                      LD       C,(HL)      ; BC = Number of dimens
 2713 122B 0600                    LD       B,0
 2714 122D 09                      ADD      HL,BC       ; Two bytes per dimensi
 2715 122E 09                      ADD      HL,BC
 2716 122F 23                      INC      HL          ; Plus one for number o
 2717 1230 EB           GRBARY:    EX       DE,HL
 2718 1231 2A0A81                  LD       HL,(CUROPR) ; Get address of next a
 2719 1234 EB                      EX       DE,HL
 2720 1235 CDC006                  CALL     CPDEHL      ; Is this array finishe
 2721 1238 CA1112                  JP       Z,ARRLP     ; Yes - Get next one
 2722 123B 013012                  LD       BC,GRBARY   ; Loop until array all 
 2723 123E C5           STPOOL:    PUSH     BC          ; Save return address
 2724 123F F680                    OR       80H         ; Flag string type
 2725 1241 7E           STRADD:    LD       A,(HL)      ; Get string length
 2726 1242 23                      INC      HL
 2727 1243 23                      INC      HL
 2728 1244 5E                      LD       E,(HL)      ; Get LSB of string add
 2729 1245 23                      INC      HL
 2730 1246 56                      LD       D,(HL)      ; Get MSB of string add
 2731 1247 23                      INC      HL
 2732 1248 F0                      RET      P           ; Not a string - Return
 2733 1249 B7                      OR       A           ; Set flags on string l
 2734 124A C8                      RET      Z           ; Null string - Return
 2735 124B 44                      LD       B,H         ; Save variable pointer
 2736 124C 4D                      LD       C,L
 2737 124D 2A0881                  LD       HL,(STRBOT) ; Bottom of new area
 2738 1250 CDC006                  CALL     CPDEHL      ; String been done?
 2739 1253 60                      LD       H,B         ; Restore variable poin
 2740 1254 69                      LD       L,C
 2741 1255 D8                      RET      C           ; String done - Ignore
 2742 1256 E1                      POP      HL          ; Return address
 2743 1257 E3                      EX       (SP),HL     ; Lowest available stri
 2744 1258 CDC006                  CALL     CPDEHL      ; String within string 
 2745 125B E3                      EX       (SP),HL     ; Lowest available stri
 2746 125C E5                      PUSH     HL          ; Re-save return addres
 2747 125D 60                      LD       H,B         ; Restore variable poin
 2748 125E 69                      LD       L,C
 2749 125F D0                      RET      NC          ; Outside string area -
 2750 1260 C1                      POP      BC          ; Get return , Throw 2 
 2751 1261 F1                      POP      AF          ;
 2752 1262 F1                      POP      AF          ;
 2753 1263 E5                      PUSH     HL          ; Save variable pointer
 2754 1264 D5                      PUSH     DE          ; Save address of curre
 2755 1265 C5                      PUSH     BC          ; Put back return addre
 2756 1266 C9                      RET                  ; Go to it
 2757                   ;
 2758 1267 D1           SCNEND:    POP      DE          ; Addresses of strings
 2759 1268 E1                      POP      HL          ;
 2760 1269 7D                      LD       A,L         ; HL = 0 if no more to 
 2761 126A B4                      OR       H
 2762 126B C8                      RET      Z           ; No more to do - Retur
 2763 126C 2B                      DEC      HL
 2764 126D 46                      LD       B,(HL)      ; MSB of address of str
 2765 126E 2B                      DEC      HL
 2766 126F 4E                      LD       C,(HL)      ; LSB of address of str
 2767 1270 E5                      PUSH     HL          ; Save variable address
 2768 1271 2B                      DEC      HL
 2769 1272 2B                      DEC      HL
 2770 1273 6E                      LD       L,(HL)      ; HL = Length of string
 2771 1274 2600                    LD       H,0
 2772 1276 09                      ADD      HL,BC       ; Address of end of str
 2773 1277 50                      LD       D,B         ; String address to DE
 2774 1278 59                      LD       E,C
 2775 1279 2B                      DEC      HL          ; Last byte in string
 2776 127A 44                      LD       B,H         ; Address to BC
 2777 127B 4D                      LD       C,L
 2778 127C 2A0881                  LD       HL,(STRBOT) ; Current bottom of str
 2779 127F CDC703                  CALL     MOVSTR      ; Move string to new ad
 2780 1282 E1                      POP      HL          ; Restore variable addr
 2781 1283 71                      LD       (HL),C      ; Save new LSB of addre
 2782 1284 23                      INC      HL
 2783 1285 70                      LD       (HL),B      ; Save new MSB of addre
 2784 1286 69                      LD       L,C         ; Next string area+1 to
 2785 1287 60                      LD       H,B
 2786 1288 2B                      DEC      HL          ; Next string area addr
 2787 1289 C3DC11                  JP       GARBLP      ; Look for more strings
 2788                   ;
 2789 128C C5           CONCAT:    PUSH     BC          ; Save prec' opr & code
 2790 128D E5                      PUSH     HL          ;
 2791 128E 2A2981                  LD       HL,(FPREG)  ; Get first string
 2792 1291 E3                      EX       (SP),HL     ; Save first string
 2793 1292 CD460D                  CALL     OPRND       ; Get second string
 2794 1295 E3                      EX       (SP),HL     ; Restore first string
 2795 1296 CDC10C                  CALL     TSTSTR      ; Make sure it's a stri
 2796 1299 7E                      LD       A,(HL)      ; Get length of second 
 2797 129A E5                      PUSH     HL          ; Save first string
 2798 129B 2A2981                  LD       HL,(FPREG)  ; Get second string
 2799 129E E5                      PUSH     HL          ; Save second string
 2800 129F 86                      ADD      A,(HL)      ; Add length of second 
 2801 12A0 1E1C                    LD       E,LS        ; ?LS Error
 2802 12A2 DA0C04                  JP       C,ERROR     ; String too long - Err
 2803 12A5 CD4511                  CALL     MKTMST      ; Make temporary string
 2804 12A8 D1                      POP      DE          ; Get second string to 
 2805 12A9 CDDD12                  CALL     GSTRDE      ; Move to string pool i
 2806 12AC E3                      EX       (SP),HL     ; Get first string
 2807 12AD CDDC12                  CALL     GSTRHL      ; Move to string pool i
 2808 12B0 E5                      PUSH     HL          ; Save first string
 2809 12B1 2A0681                  LD       HL,(TMPSTR+2) ; Temporary string ad
 2810 12B4 EB                      EX       DE,HL       ; To DE
 2811 12B5 CDC312                  CALL     SSTSA       ; First string to strin
 2812 12B8 CDC312                  CALL     SSTSA       ; Second string to stri
 2813 12BB 21DB0C                  LD       HL,EVAL2    ; Return to evaluation 
 2814 12BE E3                      EX       (SP),HL     ; Save return,get code 
 2815 12BF E5                      PUSH     HL          ; Save code string addr
 2816 12C0 C37611                  JP       TSTOPL      ; To temporary string t
 2817                   ;
 2818 12C3 E1           SSTSA:     POP      HL          ; Return address
 2819 12C4 E3                      EX       (SP),HL     ; Get string block,save
 2820 12C5 7E                      LD       A,(HL)      ; Get length of string
 2821 12C6 23                      INC      HL
 2822 12C7 23                      INC      HL
 2823 12C8 4E                      LD       C,(HL)      ; Get LSB of string add
 2824 12C9 23                      INC      HL
 2825 12CA 46                      LD       B,(HL)      ; Get MSB of string add
 2826 12CB 6F                      LD       L,A         ; Length to L
 2827 12CC 2C           TOSTRA:    INC      L           ; INC - DECed after
 2828 12CD 2D           TSALP:     DEC      L           ; Count bytes moved
 2829 12CE C8                      RET      Z           ; End of string - Retur
 2830 12CF 0A                      LD       A,(BC)      ; Get source
 2831 12D0 12                      LD       (DE),A      ; Save destination
 2832 12D1 03                      INC      BC          ; Next source
 2833 12D2 13                      INC      DE          ; Next destination
 2834 12D3 C3CD12                  JP       TSALP       ; Loop until string mov
 2835                   ;
 2836 12D6 CDC10C       GETSTR:    CALL     TSTSTR      ; Make sure it's a stri
 2837 12D9 2A2981       GSTRCU:    LD       HL,(FPREG)  ; Get current string
 2838 12DC EB           GSTRHL:    EX       DE,HL       ; Save DE
 2839 12DD CDF712       GSTRDE:    CALL     BAKTMP      ; Was it last tmp-str?
 2840 12E0 EB                      EX       DE,HL       ; Restore DE
 2841 12E1 C0                      RET      NZ          ; No - Return
 2842 12E2 D5                      PUSH     DE          ; Save string
 2843 12E3 50                      LD       D,B         ; String block address 
 2844 12E4 59                      LD       E,C
 2845 12E5 1B                      DEC      DE          ; Point to length
 2846 12E6 4E                      LD       C,(HL)      ; Get string length
 2847 12E7 2A0881                  LD       HL,(STRBOT) ; Current bottom of str
 2848 12EA CDC006                  CALL     CPDEHL      ; Last one in string ar
 2849 12ED C2F512                  JP       NZ,POPHL    ; No - Return
 2850 12F0 47                      LD       B,A         ; Clear B (A=0)
 2851 12F1 09                      ADD      HL,BC       ; Remove string from st
 2852 12F2 220881                  LD       (STRBOT),HL ; Save new bottom of st
 2853 12F5 E1           POPHL:     POP      HL          ; Restore string
 2854 12F6 C9                      RET
 2855                   ;
 2856 12F7 2AF680       BAKTMP:    LD       HL,(TMSTPT) ; Get temporary string 
 2857 12FA 2B                      DEC      HL          ; Back
 2858 12FB 46                      LD       B,(HL)      ; Get MSB of address
 2859 12FC 2B                      DEC      HL          ; Back
 2860 12FD 4E                      LD       C,(HL)      ; Get LSB of address
 2861 12FE 2B                      DEC      HL          ; Back
 2862 12FF 2B                      DEC      HL          ; Back
 2863 1300 CDC006                  CALL     CPDEHL      ; String last in string
 2864 1303 C0                      RET      NZ          ; Yes - Leave it
 2865 1304 22F680                  LD       (TMSTPT),HL ; Save new string pool 
 2866 1307 C9                      RET
 2867                   ;
 2868 1308 018710       LEN:       LD       BC,PASSA    ; To return integer A
 2869 130B C5                      PUSH     BC          ; Save address
 2870 130C CDD612       GETLEN:    CALL     GETSTR      ; Get string and its le
 2871 130F AF                      XOR      A
 2872 1310 57                      LD       D,A         ; Clear D
 2873 1311 32F280                  LD       (TYPE),A    ; Set type to numeric
 2874 1314 7E                      LD       A,(HL)      ; Get length of string
 2875 1315 B7                      OR       A           ; Set status flags
 2876 1316 C9                      RET
 2877                   ;
 2878 1317 018710       ASC:       LD       BC,PASSA    ; To return integer A
 2879 131A C5                      PUSH     BC          ; Save address
 2880 131B CD0C13       GTFLNM:    CALL     GETLEN      ; Get length of string
 2881 131E CA1709                  JP       Z,FCERR     ; Null string - Error
 2882 1321 23                      INC      HL
 2883 1322 23                      INC      HL
 2884 1323 5E                      LD       E,(HL)      ; Get LSB of address
 2885 1324 23                      INC      HL
 2886 1325 56                      LD       D,(HL)      ; Get MSB of address
 2887 1326 1A                      LD       A,(DE)      ; Get first byte of str
 2888 1327 C9                      RET
 2889                   ;
 2890 1328 3E01         CHR:       LD       A,1         ; One character string
 2891 132A CD4511                  CALL     MKTMST      ; Make a temporary stri
 2892 132D CD2114                  CALL     MAKINT      ; Make it integer A
 2893 1330 2A0681                  LD       HL,(TMPSTR+2) ; Get address of stri
 2894 1333 73                      LD       (HL),E      ; Save character
 2895 1334 C1           TOPOOL:    POP      BC          ; Clean up stack
 2896 1335 C37611                  JP       TSTOPL      ; Temporary string to p
 2897                   ;
 2898 1338 CDD113       LEFT:      CALL     LFRGNM      ; Get number and ending
 2899 133B AF                      XOR      A           ; Start at first byte i
 2900 133C E3           RIGHT1:    EX       (SP),HL     ; Save code string,Get 
 2901 133D 4F                      LD       C,A         ; Starting position in 
 2902 133E E5           MID1:      PUSH     HL          ; Save string block add
 2903 133F 7E                      LD       A,(HL)      ; Get length of string
 2904 1340 B8                      CP       B           ; Compare with number g
 2905 1341 DA4613                  JP       C,ALLFOL    ; All following bytes r
 2906 1344 78                      LD       A,B         ; Get new length
 2907 1345 11                      DB       11H         ; Skip "LD C,0"
 2908 1346 0E00         ALLFOL:    LD       C,0         ; First byte of string
 2909 1348 C5                      PUSH     BC          ; Save position in stri
 2910 1349 CDAF11                  CALL     TESTR       ; See if enough string 
 2911 134C C1                      POP      BC          ; Get position in strin
 2912 134D E1                      POP      HL          ; Restore string block 
 2913 134E E5                      PUSH     HL          ; And re-save it
 2914 134F 23                      INC      HL
 2915 1350 23                      INC      HL
 2916 1351 46                      LD       B,(HL)      ; Get LSB of address
 2917 1352 23                      INC      HL
 2918 1353 66                      LD       H,(HL)      ; Get MSB of address
 2919 1354 68                      LD       L,B         ; HL = address of strin
 2920 1355 0600                    LD       B,0         ; BC = starting address
 2921 1357 09                      ADD      HL,BC       ; Point to that byte
 2922 1358 44                      LD       B,H         ; BC = source string
 2923 1359 4D                      LD       C,L
 2924 135A CD4811                  CALL     CRTMST      ; Create a string entry
 2925 135D 6F                      LD       L,A         ; Length of new string
 2926 135E CDCC12                  CALL     TOSTRA      ; Move string to string
 2927 1361 D1                      POP      DE          ; Clear stack
 2928 1362 CDDD12                  CALL     GSTRDE      ; Move to string pool i
 2929 1365 C37611                  JP       TSTOPL      ; Temporary string to p
 2930                   ;
 2931 1368 CDD113       RIGHT:     CALL     LFRGNM      ; Get number and ending
 2932 136B D1                      POP      DE          ; Get string length
 2933 136C D5                      PUSH     DE          ; And re-save
 2934 136D 1A                      LD       A,(DE)      ; Get length
 2935 136E 90                      SUB      B           ; Move back N bytes
 2936 136F C33C13                  JP       RIGHT1      ; Go and get sub-string
 2937                   ;
 2938 1372 EB           MID:       EX       DE,HL       ; Get code string addre
 2939 1373 7E                      LD       A,(HL)      ; Get next byte ',' or 
 2940 1374 CDD613                  CALL     MIDNUM      ; Get number supplied
 2941 1377 04                      INC      B           ; Is it character zero?
 2942 1378 05                      DEC      B
 2943 1379 CA1709                  JP       Z,FCERR     ; Yes - Error
 2944 137C C5                      PUSH     BC          ; Save starting positio
 2945 137D 1EFF                    LD       E,255       ; All of string
 2946 137F FE29                    CP       ')'         ; Any length given?
 2947 1381 CA8B13                  JP       Z,RSTSTR    ; No - Rest of string
 2948 1384 CDC606                  CALL     CHKSYN      ; Make sure ',' follows
 2949 1387 2C                      DB       ','
 2950 1388 CD1E14                  CALL     GETINT      ; Get integer 0-255
 2951 138B CDC606       RSTSTR:    CALL     CHKSYN      ; Make sure ")" follows
 2952 138E 29                      DB       ")"
 2953 138F F1                      POP      AF          ; Restore starting posi
 2954 1390 E3                      EX       (SP),HL     ; Get string,8ave code 
 2955 1391 013E13                  LD       BC,MID1     ; Continuation of MID$ 
 2956 1394 C5                      PUSH     BC          ; Save for return
 2957 1395 3D                      DEC      A           ; Starting position-1
 2958 1396 BE                      CP       (HL)        ; Compare with length
 2959 1397 0600                    LD       B,0         ; Zero bytes length
 2960 1399 D0                      RET      NC          ; Null string if start 
 2961 139A 4F                      LD       C,A         ; Save starting positio
 2962 139B 7E                      LD       A,(HL)      ; Get length of string
 2963 139C 91                      SUB      C           ; Subtract start
 2964 139D BB                      CP       E           ; Enough string for it?
 2965 139E 47                      LD       B,A         ; Save maximum length a
 2966 139F D8                      RET      C           ; Truncate string if ne
 2967 13A0 43                      LD       B,E         ; Set specified length
 2968 13A1 C9                      RET                  ; Go and create string
 2969                   ;
 2970 13A2 CD0C13       VAL:       CALL     GETLEN      ; Get length of string
 2971 13A5 CABF14                  JP       Z,RESZER    ; Result zero
 2972 13A8 5F                      LD       E,A         ; Save length
 2973 13A9 23                      INC      HL
 2974 13AA 23                      INC      HL
 2975 13AB 7E                      LD       A,(HL)      ; Get LSB of address
 2976 13AC 23                      INC      HL
 2977 13AD 66                      LD       H,(HL)      ; Get MSB of address
 2978 13AE 6F                      LD       L,A         ; HL = String address
 2979 13AF E5                      PUSH     HL          ; Save string address
 2980 13B0 19                      ADD      HL,DE
 2981 13B1 46                      LD       B,(HL)      ; Get end of string+1 b
 2982 13B2 72                      LD       (HL),D      ; Zero it to terminate
 2983 13B3 E3                      EX       (SP),HL     ; Save string end,get s
 2984 13B4 C5                      PUSH     BC          ; Save end+1 byte
 2985 13B5 7E                      LD       A,(HL)      ; Get starting byte
 2986 13B6 FE24                    CP       '$'         ; Hex number indicated?
 2987 13B8 C2C013                  JP       NZ,VAL1
 2988 13BB CDEA1B                  CALL     HEXTFP      ; Convert Hex to FPREG
 2989 13BE 180D                    JR       VAL3
 2990 13C0 FE25         VAL1:      CP       '%'         ; Binary number indicat
 2991 13C2 C2CA13                  JP       NZ,VAL2
 2992 13C5 CD5A1C                  CALL     BINTFP      ; Convert Bin to FPREG
 2993 13C8 1803                    JR       VAL3
 2994 13CA CDA617       VAL2:      CALL     ASCTFP      ; Convert ASCII string 
 2995 13CD C1           VAL3:      POP      BC          ; Restore end+1 byte
 2996 13CE E1                      POP      HL          ; Restore end+1 address
 2997 13CF 70                      LD       (HL),B      ; Put back original byt
 2998 13D0 C9                      RET
 2999                   ;
 3000 13D1 EB           LFRGNM:    EX       DE,HL       ; Code string address t
 3001 13D2 CDC606                  CALL     CHKSYN      ; Make sure ")" follows
 3002 13D5 29                      DB       ")"
 3003 13D6 C1           MIDNUM:    POP      BC          ; Get return address
 3004 13D7 D1                      POP      DE          ; Get number supplied
 3005 13D8 C5                      PUSH     BC          ; Re-save return addres
 3006 13D9 43                      LD       B,E         ; Number to B
 3007 13DA C9                      RET
 3008                   ;
 3009 13DB CD2114       INP:       CALL     MAKINT      ; Make it integer A
 3010 13DE 328480                  LD       (INPORT),A  ; Set input port
 3011 13E1 CD8380                  CALL     INPSUB      ; Get input from port
 3012 13E4 C38710                  JP       PASSA       ; Return integer A
 3013                   ;
 3014 13E7 CD0B14       POUT:      CALL     SETIO       ; Set up port number
 3015 13EA C34B80                  JP       OUTSUB      ; Output data and retur
 3016                   ;
 3017 13ED CD0B14       WAIT:      CALL     SETIO       ; Set up port number
 3018 13F0 F5                      PUSH     AF          ; Save AND mask
 3019 13F1 1E00                    LD       E,0         ; Assume zero if none g
 3020 13F3 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 3021 13F4 CD5008                  CALL     GETCHR      ; Get next character
 3022 13F7 CA0114                  JP       Z,NOXOR     ; No XOR byte given
 3023 13FA CDC606                  CALL     CHKSYN      ; Make sure ',' follows
 3024 13FD 2C                      DB       ','
 3025 13FE CD1E14                  CALL     GETINT      ; Get integer 0-255 to 
 3026 1401 C1           NOXOR:     POP      BC          ; Restore AND mask
 3027 1402 CD8380       WAITLP:    CALL     INPSUB      ; Get input
 3028 1405 AB                      XOR      E           ; Flip selected bits
 3029 1406 A0                      AND      B           ; Result non-zero?
 3030 1407 CA0214                  JP       Z,WAITLP    ; No = keep waiting
 3031 140A C9                      RET
 3032                   ;
 3033 140B CD1E14       SETIO:     CALL     GETINT      ; Get integer 0-255
 3034 140E 328480                  LD       (INPORT),A  ; Set input port
 3035 1411 324C80                  LD       (OTPORT),A  ; Set output port
 3036 1414 CDC606                  CALL     CHKSYN      ; Make sure ',' follows
 3037 1417 2C                      DB       ','
 3038 1418 C31E14                  JP       GETINT      ; Get integer 0-255 and
 3039                   ;
 3040 141B CD5008       FNDNUM:    CALL     GETCHR      ; Get next character
 3041 141E CDBD0C       GETINT:    CALL     GETNUM      ; Get a number from 0 t
 3042 1421 CDFC08       MAKINT:    CALL     DEPINT      ; Make sure value 0 - 2
 3043 1424 7A                      LD       A,D         ; Get MSB of number
 3044 1425 B7                      OR       A           ; Zero?
 3045 1426 C21709                  JP       NZ,FCERR    ; No - Error
 3046 1429 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 3047 142A CD5008                  CALL     GETCHR      ; Get next character
 3048 142D 7B                      LD       A,E         ; Get number to A
 3049 142E C9                      RET
 3050                   ;
 3051 142F CD0209       PEEK:      CALL     DEINT       ; Get memory address
 3052 1432 1A                      LD       A,(DE)      ; Get byte in memory
 3053 1433 C38710                  JP       PASSA       ; Return integer A
 3054                   ;
 3055 1436 CDBD0C       POKE:      CALL     GETNUM      ; Get memory address
 3056 1439 CD0209                  CALL     DEINT       ; Get integer -32768 to
 3057 143C D5                      PUSH     DE          ; Save memory address
 3058 143D CDC606                  CALL     CHKSYN      ; Make sure ',' follows
 3059 1440 2C                      DB       ','
 3060 1441 CD1E14                  CALL     GETINT      ; Get integer 0-255
 3061 1444 D1                      POP      DE          ; Restore memory addres
 3062 1445 12                      LD       (DE),A      ; Load it into memory
 3063 1446 C9                      RET
 3064                   ;
 3065 1447 211D19       ROUND:     LD       HL,HALF     ; Add 0.5 to FPREG
 3066 144A CDEE16       ADDPHL:    CALL     LOADFP      ; Load FP at (HL) to BC
 3067 144D C35914                  JP       FPADD       ; Add BCDE to FPREG
 3068                   ;
 3069 1450 CDEE16       SUBPHL:    CALL     LOADFP      ; FPREG = -FPREG + numb
 3070 1453 21                      DB       21H         ; Skip "POP BC" and "PO
 3071 1454 C1           PSUB:      POP      BC          ; Get FP number from st
 3072 1455 D1                      POP      DE
 3073 1456 CDC816       SUBCDE:    CALL     INVSGN      ; Negate FPREG
 3074 1459 78           FPADD:     LD       A,B         ; Get FP exponent
 3075 145A B7                      OR       A           ; Is number zero?
 3076 145B C8                      RET      Z           ; Yes - Nothing to add
 3077 145C 3A2C81                  LD       A,(FPEXP)   ; Get FPREG exponent
 3078 145F B7                      OR       A           ; Is this number zero?
 3079 1460 CAE016                  JP       Z,FPBCDE    ; Yes - Move BCDE to FP
 3080 1463 90                      SUB      B           ; BCDE number larger?
 3081 1464 D27314                  JP       NC,NOSWAP   ; No - Don't swap them
 3082 1467 2F                      CPL                  ; Two's complement
 3083 1468 3C                      INC      A           ;       FP exponent
 3084 1469 EB                      EX       DE,HL
 3085 146A CDD016                  CALL     STAKFP      ; Put FPREG on stack
 3086 146D EB                      EX       DE,HL
 3087 146E CDE016                  CALL     FPBCDE      ; Move BCDE to FPREG
 3088 1471 C1                      POP      BC          ; Restore number from s
 3089 1472 D1                      POP      DE
 3090 1473 FE19         NOSWAP:    CP       24+1        ; Second number insigni
 3091 1475 D0                      RET      NC          ; Yes - First number is
 3092 1476 F5                      PUSH     AF          ; Save number of bits t
 3093 1477 CD0517                  CALL     SIGNS       ; Set MSBs & sign of re
 3094 147A 67                      LD       H,A         ; Save sign of result
 3095 147B F1                      POP      AF          ; Restore scaling facto
 3096 147C CD1E15                  CALL     SCALE       ; Scale BCDE to same ex
 3097 147F B4                      OR       H           ; Result to be positive
 3098 1480 212981                  LD       HL,FPREG    ; Point to FPREG
 3099 1483 F29914                  JP       P,MINCDE    ; No - Subtract FPREG f
 3100 1486 CDFE14                  CALL     PLUCDE      ; Add FPREG to CDE
 3101 1489 D2DF14                  JP       NC,RONDUP   ; No overflow - Round i
 3102 148C 23                      INC      HL          ; Point to exponent
 3103 148D 34                      INC      (HL)        ; Increment it
 3104 148E CA0704                  JP       Z,OVERR     ; Number overflowed - E
 3105 1491 2E01                    LD       L,1         ; 1 bit to shift right
 3106 1493 CD3415                  CALL     SHRT1       ; Shift result right
 3107 1496 C3DF14                  JP       RONDUP      ; Round it up
 3108                   ;
 3109 1499 AF           MINCDE:    XOR      A           ; Clear A and carry
 3110 149A 90                      SUB      B           ; Negate exponent
 3111 149B 47                      LD       B,A         ; Re-save exponent
 3112 149C 7E                      LD       A,(HL)      ; Get LSB of FPREG
 3113 149D 9B                      SBC      A, E        ; Subtract LSB of BCDE
 3114 149E 5F                      LD       E,A         ; Save LSB of BCDE
 3115 149F 23                      INC      HL
 3116 14A0 7E                      LD       A,(HL)      ; Get NMSB of FPREG
 3117 14A1 9A                      SBC      A,D         ; Subtract NMSB of BCDE
 3118 14A2 57                      LD       D,A         ; Save NMSB of BCDE
 3119 14A3 23                      INC      HL
 3120 14A4 7E                      LD       A,(HL)      ; Get MSB of FPREG
 3121 14A5 99                      SBC      A,C         ; Subtract MSB of BCDE
 3122 14A6 4F                      LD       C,A         ; Save MSB of BCDE
 3123 14A7 DC0A15       CONPOS:    CALL     C,COMPL     ; Overflow - Make it po
 3124                   ;
 3125 14AA 68           BNORM:     LD       L,B         ; L = Exponent
 3126 14AB 63                      LD       H,E         ; H = LSB
 3127 14AC AF                      XOR      A
 3128 14AD 47           BNRMLP:    LD       B,A         ; Save bit count
 3129 14AE 79                      LD       A,C         ; Get MSB
 3130 14AF B7                      OR       A           ; Is it zero?
 3131 14B0 C2CC14                  JP       NZ,PNORM    ; No - Do it bit at a t
 3132 14B3 4A                      LD       C,D         ; MSB = NMSB
 3133 14B4 54                      LD       D,H         ; NMSB= LSB
 3134 14B5 65                      LD       H,L         ; LSB = VLSB
 3135 14B6 6F                      LD       L,A         ; VLSB= 0
 3136 14B7 78                      LD       A,B         ; Get exponent
 3137 14B8 D608                    SUB      8           ; Count 8 bits
 3138 14BA FEE0                    CP       0E0H        ; -24-8 Was number zero
 3139 14BC C2AD14                  JP       NZ,BNRMLP   ; No - Keep normalising
 3140 14BF AF           RESZER:    XOR      A           ; Result is zero
 3141 14C0 322C81       SAVEXP:    LD       (FPEXP),A   ; Save result as zero
 3142 14C3 C9                      RET
 3143                   ;
 3144 14C4 05           NORMAL:    DEC      B           ; Count bits
 3145 14C5 29                      ADD      HL,HL       ; Shift HL left
 3146 14C6 7A                      LD       A,D         ; Get NMSB
 3147 14C7 17                      RLA                  ; Shift left with last 
 3148 14C8 57                      LD       D,A         ; Save NMSB
 3149 14C9 79                      LD       A,C         ; Get MSB
 3150 14CA 8F                      ADC      A,A         ; Shift left with last 
 3151 14CB 4F                      LD       C,A         ; Save MSB
 3152 14CC F2C414       PNORM:     JP       P,NORMAL    ; Not done - Keep going
 3153 14CF 78                      LD       A,B         ; Number of bits shifte
 3154 14D0 5C                      LD       E,H         ; Save HL in EB
 3155 14D1 45                      LD       B,L
 3156 14D2 B7                      OR       A           ; Any shifting done?
 3157 14D3 CADF14                  JP       Z,RONDUP    ; No - Round it up
 3158 14D6 212C81                  LD       HL,FPEXP    ; Point to exponent
 3159 14D9 86                      ADD      A,(HL)      ; Add shifted bits
 3160 14DA 77                      LD       (HL),A      ; Re-save exponent
 3161 14DB D2BF14                  JP       NC,RESZER   ; Underflow - Result is
 3162 14DE C8                      RET      Z           ; Result is zero
 3163 14DF 78           RONDUP:    LD       A,B         ; Get VLSB of number
 3164 14E0 212C81       RONDB:     LD       HL,FPEXP    ; Point to exponent
 3165 14E3 B7                      OR       A           ; Any rounding?
 3166 14E4 FCF114                  CALL     M,FPROND    ; Yes - Round number up
 3167 14E7 46                      LD       B,(HL)      ; B = Exponent
 3168 14E8 23                      INC      HL
 3169 14E9 7E                      LD       A,(HL)      ; Get sign of result
 3170 14EA E680                    AND      10000000B   ; Only bit 7 needed
 3171 14EC A9                      XOR      C           ; Set correct sign
 3172 14ED 4F                      LD       C,A         ; Save correct sign in 
 3173 14EE C3E016                  JP       FPBCDE      ; Move BCDE to FPREG
 3174                   ;
 3175 14F1 1C           FPROND:    INC      E           ; Round LSB
 3176 14F2 C0                      RET      NZ          ; Return if ok
 3177 14F3 14                      INC      D           ; Round NMSB
 3178 14F4 C0                      RET      NZ          ; Return if ok
 3179 14F5 0C                      INC      C           ; Round MSB
 3180 14F6 C0                      RET      NZ          ; Return if ok
 3181 14F7 0E80                    LD       C,80H       ; Set normal value
 3182 14F9 34                      INC      (HL)        ; Increment exponent
 3183 14FA C0                      RET      NZ          ; Return if ok
 3184 14FB C30704                  JP       OVERR       ; Overflow error
 3185                   ;
 3186 14FE 7E           PLUCDE:    LD       A,(HL)      ; Get LSB of FPREG
 3187 14FF 83                      ADD      A,E         ; Add LSB of BCDE
 3188 1500 5F                      LD       E,A         ; Save LSB of BCDE
 3189 1501 23                      INC      HL
 3190 1502 7E                      LD       A,(HL)      ; Get NMSB of FPREG
 3191 1503 8A                      ADC      A,D         ; Add NMSB of BCDE
 3192 1504 57                      LD       D,A         ; Save NMSB of BCDE
 3193 1505 23                      INC      HL
 3194 1506 7E                      LD       A,(HL)      ; Get MSB of FPREG
 3195 1507 89                      ADC      A,C         ; Add MSB of BCDE
 3196 1508 4F                      LD       C,A         ; Save MSB of BCDE
 3197 1509 C9                      RET
 3198                   ;
 3199 150A 212D81       COMPL:     LD       HL,SGNRES   ; Sign of result
 3200 150D 7E                      LD       A,(HL)      ; Get sign of result
 3201 150E 2F                      CPL                  ; Negate it
 3202 150F 77                      LD       (HL),A      ; Put it back
 3203 1510 AF                      XOR      A
 3204 1511 6F                      LD       L,A         ; Set L to zero
 3205 1512 90                      SUB      B           ; Negate exponent,set c
 3206 1513 47                      LD       B,A         ; Re-save exponent
 3207 1514 7D                      LD       A,L         ; Load zero
 3208 1515 9B                      SBC      A,E         ; Negate LSB
 3209 1516 5F                      LD       E,A         ; Re-save LSB
 3210 1517 7D                      LD       A,L         ; Load zero
 3211 1518 9A                      SBC      A,D         ; Negate NMSB
 3212 1519 57                      LD       D,A         ; Re-save NMSB
 3213 151A 7D                      LD       A,L         ; Load zero
 3214 151B 99                      SBC      A,C         ; Negate MSB
 3215 151C 4F                      LD       C,A         ; Re-save MSB
 3216 151D C9                      RET
 3217                   ;
 3218 151E 0600         SCALE:     LD       B,0         ; Clear underflow
 3219 1520 D608         SCALLP:    SUB      8           ; 8 bits (a whole byte)
 3220 1522 DA2D15                  JP       C,SHRITE    ; No - Shift right A bi
 3221 1525 43                      LD       B,E         ; <- Shift
 3222 1526 5A                      LD       E,D         ; <- right
 3223 1527 51                      LD       D,C         ; <- eight
 3224 1528 0E00                    LD       C,0         ; <- bits
 3225 152A C32015                  JP       SCALLP      ; More bits to shift
 3226                   ;
 3227 152D C609         SHRITE:    ADD      A,8+1       ; Adjust count
 3228 152F 6F                      LD       L,A         ; Save bits to shift
 3229 1530 AF           SHRLP:     XOR      A           ; Flag for all done
 3230 1531 2D                      DEC      L           ; All shifting done?
 3231 1532 C8                      RET      Z           ; Yes - Return
 3232 1533 79                      LD       A,C         ; Get MSB
 3233 1534 1F           SHRT1:     RRA                  ; Shift it right
 3234 1535 4F                      LD       C,A         ; Re-save
 3235 1536 7A                      LD       A,D         ; Get NMSB
 3236 1537 1F                      RRA                  ; Shift right with last
 3237 1538 57                      LD       D,A         ; Re-save it
 3238 1539 7B                      LD       A,E         ; Get LSB
 3239 153A 1F                      RRA                  ; Shift right with last
 3240 153B 5F                      LD       E,A         ; Re-save it
 3241 153C 78                      LD       A,B         ; Get underflow
 3242 153D 1F                      RRA                  ; Shift right with last
 3243 153E 47                      LD       B,A         ; Re-save underflow
 3244 153F C33015                  JP       SHRLP       ; More bits to do
 3245                   ;
 3246 1542 00000081     UNITY:     DB       000H,000H,000H,081H ; 1.00000
 3247                   ;
 3248 1546 03           LOGTAB:    DB       3           ; Table used by LOG
 3249 1547 AA561980                DB       0AAH,056H,019H,080H ; 0.59898
 3250 154B F1227680                DB       0F1H,022H,076H,080H ; 0.96147
 3251 154F 45AA3882                DB       045H,0AAH,038H,082H ; 2.88539
 3252                   ;
 3253 1553 CD9F16       LOG:       CALL     TSTSGN      ; Test sign of value
 3254 1556 B7                      OR       A
 3255 1557 EA1709                  JP       PE,FCERR    ; ?FC Error if <= zero
 3256 155A 212C81                  LD       HL,FPEXP    ; Point to exponent
 3257 155D 7E                      LD       A,(HL)      ; Get exponent
 3258 155E 013580                  LD       BC,8035H    ; BCDE = SQR(1/2)
 3259 1561 11F304                  LD       DE,04F3H
 3260 1564 90                      SUB      B           ; Scale value to be < 1
 3261 1565 F5                      PUSH     AF          ; Save scale factor
 3262 1566 70                      LD       (HL),B      ; Save new exponent
 3263 1567 D5                      PUSH     DE          ; Save SQR(1/2)
 3264 1568 C5                      PUSH     BC
 3265 1569 CD5914                  CALL     FPADD       ; Add SQR(1/2) to value
 3266 156C C1                      POP      BC          ; Restore SQR(1/2)
 3267 156D D1                      POP      DE
 3268 156E 04                      INC      B           ; Make it SQR(2)
 3269 156F CDF515                  CALL     DVBCDE      ; Divide by SQR(2)
 3270 1572 214215                  LD       HL,UNITY    ; Point to 1.
 3271 1575 CD5014                  CALL     SUBPHL      ; Subtract FPREG from 1
 3272 1578 214615                  LD       HL,LOGTAB   ; Coefficient table
 3273 157B CDE719                  CALL     SUMSER      ; Evaluate sum of serie
 3274 157E 018080                  LD       BC,8080H    ; BCDE = -0.5
 3275 1581 110000                  LD       DE,0000H
 3276 1584 CD5914                  CALL     FPADD       ; Subtract 0.5 from FPR
 3277 1587 F1                      POP      AF          ; Restore scale factor
 3278 1588 CD1A18                  CALL     RSCALE      ; Re-scale number
 3279 158B 013180       MULLN2:    LD       BC,8031H    ; BCDE = Ln(2)
 3280 158E 111872                  LD       DE,7218H
 3281 1591 21                      DB       21H         ; Skip "POP BC" and "PO
 3282                   ;
 3283 1592 C1           MULT:      POP      BC          ; Get number from stack
 3284 1593 D1                      POP      DE
 3285 1594 CD9F16       FPMULT:    CALL     TSTSGN      ; Test sign of FPREG
 3286 1597 C8                      RET      Z           ; Return zero if zero
 3287 1598 2E00                    LD       L,0         ; Flag add exponents
 3288 159A CD5D16                  CALL     ADDEXP      ; Add exponents
 3289 159D 79                      LD       A,C         ; Get MSB of multiplier
 3290 159E 323B81                  LD       (MULVAL),A  ; Save MSB of multiplie
 3291 15A1 EB                      EX       DE,HL
 3292 15A2 223C81                  LD       (MULVAL+1),HL ; Save rest of multip
 3293 15A5 010000                  LD       BC,0        ; Partial product (BCDE
 3294 15A8 50                      LD       D,B
 3295 15A9 58                      LD       E,B
 3296 15AA 21AA14                  LD       HL,BNORM    ; Address of normalise
 3297 15AD E5                      PUSH     HL          ; Save for return
 3298 15AE 21B615                  LD       HL,MULT8    ; Address of 8 bit mult
 3299 15B1 E5                      PUSH     HL          ; Save for NMSB,MSB
 3300 15B2 E5                      PUSH     HL          ;
 3301 15B3 212981                  LD       HL,FPREG    ; Point to number
 3302 15B6 7E           MULT8:     LD       A,(HL)      ; Get LSB of number
 3303 15B7 23                      INC      HL          ; Point to NMSB
 3304 15B8 B7                      OR       A           ; Test LSB
 3305 15B9 CAE215                  JP       Z,BYTSFT    ; Zero - shift to next 
 3306 15BC E5                      PUSH     HL          ; Save address of numbe
 3307 15BD 2E08                    LD       L,8         ; 8 bits to multiply by
 3308 15BF 1F           MUL8LP:    RRA                  ; Shift LSB right
 3309 15C0 67                      LD       H,A         ; Save LSB
 3310 15C1 79                      LD       A,C         ; Get MSB
 3311 15C2 D2D015                  JP       NC,NOMADD   ; Bit was zero - Don't 
 3312 15C5 E5                      PUSH     HL          ; Save LSB and count
 3313 15C6 2A3C81                  LD       HL,(MULVAL+1) ; Get LSB and NMSB
 3314 15C9 19                      ADD      HL,DE       ; Add NMSB and LSB
 3315 15CA EB                      EX       DE,HL       ; Leave sum in DE
 3316 15CB E1                      POP      HL          ; Restore MSB and count
 3317 15CC 3A3B81                  LD       A,(MULVAL)  ; Get MSB of multiplier
 3318 15CF 89                      ADC      A,C         ; Add MSB
 3319 15D0 1F           NOMADD:    RRA                  ; Shift MSB right
 3320 15D1 4F                      LD       C,A         ; Re-save MSB
 3321 15D2 7A                      LD       A,D         ; Get NMSB
 3322 15D3 1F                      RRA                  ; Shift NMSB right
 3323 15D4 57                      LD       D,A         ; Re-save NMSB
 3324 15D5 7B                      LD       A,E         ; Get LSB
 3325 15D6 1F                      RRA                  ; Shift LSB right
 3326 15D7 5F                      LD       E,A         ; Re-save LSB
 3327 15D8 78                      LD       A,B         ; Get VLSB
 3328 15D9 1F                      RRA                  ; Shift VLSB right
 3329 15DA 47                      LD       B,A         ; Re-save VLSB
 3330 15DB 2D                      DEC      L           ; Count bits multiplied
 3331 15DC 7C                      LD       A,H         ; Get LSB of multiplier
 3332 15DD C2BF15                  JP       NZ,MUL8LP   ; More - Do it
 3333 15E0 E1           POPHRT:    POP      HL          ; Restore address of nu
 3334 15E1 C9                      RET
 3335                   ;
 3336 15E2 43           BYTSFT:    LD       B,E         ; Shift partial product
 3337 15E3 5A                      LD       E,D
 3338 15E4 51                      LD       D,C
 3339 15E5 4F                      LD       C,A
 3340 15E6 C9                      RET
 3341                   ;
 3342 15E7 CDD016       DIV10:     CALL     STAKFP      ; Save FPREG on stack
 3343 15EA 012084                  LD       BC,8420H    ; BCDE = 10.
 3344 15ED 110000                  LD       DE,0000H
 3345 15F0 CDE016                  CALL     FPBCDE      ; Move 10 to FPREG
 3346                   ;
 3347 15F3 C1           DIV:       POP      BC          ; Get number from stack
 3348 15F4 D1                      POP      DE
 3349 15F5 CD9F16       DVBCDE:    CALL     TSTSGN      ; Test sign of FPREG
 3350 15F8 CAFB03                  JP       Z,DZERR     ; Error if division by 
 3351 15FB 2EFF                    LD       L,-1        ; Flag subtract exponen
 3352 15FD CD5D16                  CALL     ADDEXP      ; Subtract exponents
 3353 1600 34                      INC      (HL)        ; Add 2 to exponent to 
 3354 1601 34                      INC      (HL)
 3355 1602 2B                      DEC      HL          ; Point to MSB
 3356 1603 7E                      LD       A,(HL)      ; Get MSB of dividend
 3357 1604 325780                  LD       (DIV3),A    ; Save for subtraction
 3358 1607 2B                      DEC      HL
 3359 1608 7E                      LD       A,(HL)      ; Get NMSB of dividend
 3360 1609 325380                  LD       (DIV2),A    ; Save for subtraction
 3361 160C 2B                      DEC      HL
 3362 160D 7E                      LD       A,(HL)      ; Get MSB of dividend
 3363 160E 324F80                  LD       (DIV1),A    ; Save for subtraction
 3364 1611 41                      LD       B,C         ; Get MSB
 3365 1612 EB                      EX       DE,HL       ; NMSB,LSB to HL
 3366 1613 AF                      XOR      A
 3367 1614 4F                      LD       C,A         ; Clear MSB of quotient
 3368 1615 57                      LD       D,A         ; Clear NMSB of quotien
 3369 1616 5F                      LD       E,A         ; Clear LSB of quotient
 3370 1617 325A80                  LD       (DIV4),A    ; Clear overflow count
 3371 161A E5           DIVLP:     PUSH     HL          ; Save divisor
 3372 161B C5                      PUSH     BC
 3373 161C 7D                      LD       A,L         ; Get LSB of number
 3374 161D CD4E80                  CALL     DIVSUP      ; Subt' divisor from di
 3375 1620 DE00                    SBC      A,0         ; Count for overflows
 3376 1622 3F                      CCF
 3377 1623 D22D16                  JP       NC,RESDIV   ; Restore divisor if bo
 3378 1626 325A80                  LD       (DIV4),A    ; Re-save overflow coun
 3379 1629 F1                      POP      AF          ; Scrap divisor
 3380 162A F1                      POP      AF
 3381 162B 37                      SCF                  ; Set carry to
 3382 162C D2                      DB       0D2H        ; Skip "POP BC" and "PO
 3383                   ;
 3384 162D C1           RESDIV:    POP      BC          ; Restore divisor
 3385 162E E1                      POP      HL
 3386 162F 79                      LD       A,C         ; Get MSB of quotient
 3387 1630 3C                      INC      A
 3388 1631 3D                      DEC      A
 3389 1632 1F                      RRA                  ; Bit 0 to bit 7
 3390 1633 FAE014                  JP       M,RONDB     ; Done - Normalise resu
 3391 1636 17                      RLA                  ; Restore carry
 3392 1637 7B                      LD       A,E         ; Get LSB of quotient
 3393 1638 17                      RLA                  ; Double it
 3394 1639 5F                      LD       E,A         ; Put it back
 3395 163A 7A                      LD       A,D         ; Get NMSB of quotient
 3396 163B 17                      RLA                  ; Double it
 3397 163C 57                      LD       D,A         ; Put it back
 3398 163D 79                      LD       A,C         ; Get MSB of quotient
 3399 163E 17                      RLA                  ; Double it
 3400 163F 4F                      LD       C,A         ; Put it back
 3401 1640 29                      ADD      HL,HL       ; Double NMSB,LSB of di
 3402 1641 78                      LD       A,B         ; Get MSB of divisor
 3403 1642 17                      RLA                  ; Double it
 3404 1643 47                      LD       B,A         ; Put it back
 3405 1644 3A5A80                  LD       A,(DIV4)    ; Get VLSB of quotient
 3406 1647 17                      RLA                  ; Double it
 3407 1648 325A80                  LD       (DIV4),A    ; Put it back
 3408 164B 79                      LD       A,C         ; Get MSB of quotient
 3409 164C B2                      OR       D           ; Merge NMSB
 3410 164D B3                      OR       E           ; Merge LSB
 3411 164E C21A16                  JP       NZ,DIVLP    ; Not done - Keep divid
 3412 1651 E5                      PUSH     HL          ; Save divisor
 3413 1652 212C81                  LD       HL,FPEXP    ; Point to exponent
 3414 1655 35                      DEC      (HL)        ; Divide by 2
 3415 1656 E1                      POP      HL          ; Restore divisor
 3416 1657 C21A16                  JP       NZ,DIVLP    ; Ok - Keep going
 3417 165A C30704                  JP       OVERR       ; Overflow error
 3418                   ;
 3419 165D 78           ADDEXP:    LD       A,B         ; Get exponent of divid
 3420 165E B7                      OR       A           ; Test it
 3421 165F CA8116                  JP       Z,OVTST3    ; Zero - Result zero
 3422 1662 7D                      LD       A,L         ; Get add/subtract flag
 3423 1663 212C81                  LD       HL,FPEXP    ; Point to exponent
 3424 1666 AE                      XOR      (HL)        ; Add or subtract it
 3425 1667 80                      ADD      A,B         ; Add the other exponen
 3426 1668 47                      LD       B,A         ; Save new exponent
 3427 1669 1F                      RRA                  ; Test exponent for ove
 3428 166A A8                      XOR      B
 3429 166B 78                      LD       A,B         ; Get exponent
 3430 166C F28016                  JP       P,OVTST2    ; Positive - Test for o
 3431 166F C680                    ADD      A,80H       ; Add excess 128
 3432 1671 77                      LD       (HL),A      ; Save new exponent
 3433 1672 CAE015                  JP       Z,POPHRT    ; Zero - Result zero
 3434 1675 CD0517                  CALL     SIGNS       ; Set MSBs and sign of 
 3435 1678 77                      LD       (HL),A      ; Save new exponent
 3436 1679 2B                      DEC      HL          ; Point to MSB
 3437 167A C9                      RET
 3438                   ;
 3439 167B CD9F16       OVTST1:    CALL     TSTSGN      ; Test sign of FPREG
 3440 167E 2F                      CPL                  ; Invert sign
 3441 167F E1                      POP      HL          ; Clean up stack
 3442 1680 B7           OVTST2:    OR       A           ; Test if new exponent 
 3443 1681 E1           OVTST3:    POP      HL          ; Clear off return addr
 3444 1682 F2BF14                  JP       P,RESZER    ; Result zero
 3445 1685 C30704                  JP       OVERR       ; Overflow error
 3446                   ;
 3447 1688 CDEB16       MLSP10:    CALL     BCDEFP      ; Move FPREG to BCDE
 3448 168B 78                      LD       A,B         ; Get exponent
 3449 168C B7                      OR       A           ; Is it zero?
 3450 168D C8                      RET      Z           ; Yes - Result is zero
 3451 168E C602                    ADD      A,2         ; Multiply by 4
 3452 1690 DA0704                  JP       C,OVERR     ; Overflow - ?OV Error
 3453 1693 47                      LD       B,A         ; Re-save exponent
 3454 1694 CD5914                  CALL     FPADD       ; Add BCDE to FPREG (Ti
 3455 1697 212C81                  LD       HL,FPEXP    ; Point to exponent
 3456 169A 34                      INC      (HL)        ; Double number (Times 
 3457 169B C0                      RET      NZ          ; Ok - Return
 3458 169C C30704                  JP       OVERR       ; Overflow error
 3459                   ;
 3460 169F 3A2C81       TSTSGN:    LD       A,(FPEXP)   ; Get sign of FPREG
 3461 16A2 B7                      OR       A
 3462 16A3 C8                      RET      Z           ; RETurn if number is z
 3463 16A4 3A2B81                  LD       A,(FPREG+2) ; Get MSB of FPREG
 3464 16A7 FE                      DB       0FEH        ; Test sign
 3465 16A8 2F           RETREL:    CPL                  ; Invert sign
 3466 16A9 17                      RLA                  ; Sign bit to carry
 3467 16AA 9F           FLGDIF:    SBC      A,A         ; Carry to all bits of 
 3468 16AB C0                      RET      NZ          ; Return -1 if negative
 3469 16AC 3C                      INC      A           ; Bump to +1
 3470 16AD C9                      RET                  ; Positive - Return +1
 3471                   ;
 3472 16AE CD9F16       SGN:       CALL     TSTSGN      ; Test sign of FPREG
 3473 16B1 0688         FLGREL:    LD       B,80H+8     ; 8 bit integer in expo
 3474 16B3 110000                  LD       DE,0        ; Zero NMSB and LSB
 3475 16B6 212C81       RETINT:    LD       HL,FPEXP    ; Point to exponent
 3476 16B9 4F                      LD       C,A         ; CDE = MSB,NMSB and LS
 3477 16BA 70                      LD       (HL),B      ; Save exponent
 3478 16BB 0600                    LD       B,0         ; CDE = integer to norm
 3479 16BD 23                      INC      HL          ; Point to sign of resu
 3480 16BE 3680                    LD       (HL),80H    ; Set sign of result
 3481 16C0 17                      RLA                  ; Carry = sign of integ
 3482 16C1 C3A714                  JP       CONPOS      ; Set sign of result
 3483                   ;
 3484 16C4 CD9F16       ABS:       CALL     TSTSGN      ; Test sign of FPREG
 3485 16C7 F0                      RET      P           ; Return if positive
 3486 16C8 212B81       INVSGN:    LD       HL,FPREG+2  ; Point to MSB
 3487 16CB 7E                      LD       A,(HL)      ; Get sign of mantissa
 3488 16CC EE80                    XOR      80H         ; Invert sign of mantis
 3489 16CE 77                      LD       (HL),A      ; Re-save sign of manti
 3490 16CF C9                      RET
 3491                   ;
 3492 16D0 EB           STAKFP:    EX       DE,HL       ; Save code string addr
 3493 16D1 2A2981                  LD       HL,(FPREG)  ; LSB,NLSB of FPREG
 3494 16D4 E3                      EX       (SP),HL     ; Stack them,get return
 3495 16D5 E5                      PUSH     HL          ; Re-save return
 3496 16D6 2A2B81                  LD       HL,(FPREG+2) ; MSB and exponent of 
 3497 16D9 E3                      EX       (SP),HL     ; Stack them,get return
 3498 16DA E5                      PUSH     HL          ; Re-save return
 3499 16DB EB                      EX       DE,HL       ; Restore code string a
 3500 16DC C9                      RET
 3501                   ;
 3502 16DD CDEE16       PHLTFP:    CALL     LOADFP      ; Number at HL to BCDE
 3503 16E0 EB           FPBCDE:    EX       DE,HL       ; Save code string addr
 3504 16E1 222981                  LD       (FPREG),HL  ; Save LSB,NLSB of numb
 3505 16E4 60                      LD       H,B         ; Exponent of number
 3506 16E5 69                      LD       L,C         ; MSB of number
 3507 16E6 222B81                  LD       (FPREG+2),HL ; Save MSB and exponen
 3508 16E9 EB                      EX       DE,HL       ; Restore code string a
 3509 16EA C9                      RET
 3510                   ;
 3511 16EB 212981       BCDEFP:    LD       HL,FPREG    ; Point to FPREG
 3512 16EE 5E           LOADFP:    LD       E,(HL)      ; Get LSB of number
 3513 16EF 23                      INC      HL
 3514 16F0 56                      LD       D,(HL)      ; Get NMSB of number
 3515 16F1 23                      INC      HL
 3516 16F2 4E                      LD       C,(HL)      ; Get MSB of number
 3517 16F3 23                      INC      HL
 3518 16F4 46                      LD       B,(HL)      ; Get exponent of numbe
 3519 16F5 23           INCHL:     INC      HL          ; Used for conditional 
 3520 16F6 C9                      RET
 3521                   ;
 3522 16F7 112981       FPTHL:     LD       DE,FPREG    ; Point to FPREG
 3523 16FA 0604         DETHL4:    LD       B,4         ; 4 bytes to move
 3524 16FC 1A           DETHLB:    LD       A,(DE)      ; Get source
 3525 16FD 77                      LD       (HL),A      ; Save destination
 3526 16FE 13                      INC      DE          ; Next source
 3527 16FF 23                      INC      HL          ; Next destination
 3528 1700 05                      DEC      B           ; Count bytes
 3529 1701 C2FC16                  JP       NZ,DETHLB   ; Loop if more
 3530 1704 C9                      RET
 3531                   ;
 3532 1705 212B81       SIGNS:     LD       HL,FPREG+2  ; Point to MSB of FPREG
 3533 1708 7E                      LD       A,(HL)      ; Get MSB
 3534 1709 07                      RLCA                 ; Old sign to carry
 3535 170A 37                      SCF                  ; Set MSBit
 3536 170B 1F                      RRA                  ; Set MSBit of MSB
 3537 170C 77                      LD       (HL),A      ; Save new MSB
 3538 170D 3F                      CCF                  ; Complement sign
 3539 170E 1F                      RRA                  ; Old sign to carry
 3540 170F 23                      INC      HL
 3541 1710 23                      INC      HL
 3542 1711 77                      LD       (HL),A      ; Set sign of result
 3543 1712 79                      LD       A,C         ; Get MSB
 3544 1713 07                      RLCA                 ; Old sign to carry
 3545 1714 37                      SCF                  ; Set MSBit
 3546 1715 1F                      RRA                  ; Set MSBit of MSB
 3547 1716 4F                      LD       C,A         ; Save MSB
 3548 1717 1F                      RRA
 3549 1718 AE                      XOR      (HL)        ; New sign of result
 3550 1719 C9                      RET
 3551                   ;
 3552 171A 78           CMPNUM:    LD       A,B         ; Get exponent of numbe
 3553 171B B7                      OR       A
 3554 171C CA9F16                  JP       Z,TSTSGN    ; Zero - Test sign of F
 3555 171F 21A816                  LD       HL,RETREL   ; Return relation routi
 3556 1722 E5                      PUSH     HL          ; Save for return
 3557 1723 CD9F16                  CALL     TSTSGN      ; Test sign of FPREG
 3558 1726 79                      LD       A,C         ; Get MSB of number
 3559 1727 C8                      RET      Z           ; FPREG zero - Number's
 3560 1728 212B81                  LD       HL,FPREG+2  ; MSB of FPREG
 3561 172B AE                      XOR      (HL)        ; Combine signs
 3562 172C 79                      LD       A,C         ; Get MSB of number
 3563 172D F8                      RET      M           ; Exit if signs differe
 3564 172E CD3417                  CALL     CMPFP       ; Compare FP numbers
 3565 1731 1F                      RRA                  ; Get carry to sign
 3566 1732 A9                      XOR      C           ; Combine with MSB of n
 3567 1733 C9                      RET
 3568                   ;
 3569 1734 23           CMPFP:     INC      HL          ; Point to exponent
 3570 1735 78                      LD       A,B         ; Get exponent
 3571 1736 BE                      CP       (HL)        ; Compare exponents
 3572 1737 C0                      RET      NZ          ; Different
 3573 1738 2B                      DEC      HL          ; Point to MBS
 3574 1739 79                      LD       A,C         ; Get MSB
 3575 173A BE                      CP       (HL)        ; Compare MSBs
 3576 173B C0                      RET      NZ          ; Different
 3577 173C 2B                      DEC      HL          ; Point to NMSB
 3578 173D 7A                      LD       A,D         ; Get NMSB
 3579 173E BE                      CP       (HL)        ; Compare NMSBs
 3580 173F C0                      RET      NZ          ; Different
 3581 1740 2B                      DEC      HL          ; Point to LSB
 3582 1741 7B                      LD       A,E         ; Get LSB
 3583 1742 96                      SUB      (HL)        ; Compare LSBs
 3584 1743 C0                      RET      NZ          ; Different
 3585 1744 E1                      POP      HL          ; Drop RETurn
 3586 1745 E1                      POP      HL          ; Drop another RETurn
 3587 1746 C9                      RET
 3588                   ;
 3589 1747 47           FPINT:     LD       B,A         ; <- Move
 3590 1748 4F                      LD       C,A         ; <- exponent
 3591 1749 57                      LD       D,A         ; <- to all
 3592 174A 5F                      LD       E,A         ; <- bits
 3593 174B B7                      OR       A           ; Test exponent
 3594 174C C8                      RET      Z           ; Zero - Return zero
 3595 174D E5                      PUSH     HL          ; Save pointer to numbe
 3596 174E CDEB16                  CALL     BCDEFP      ; Move FPREG to BCDE
 3597 1751 CD0517                  CALL     SIGNS       ; Set MSBs & sign of re
 3598 1754 AE                      XOR      (HL)        ; Combine with sign of 
 3599 1755 67                      LD       H,A         ; Save combined signs
 3600 1756 FC6B17                  CALL     M,DCBCDE    ; Negative - Decrement 
 3601 1759 3E98                    LD       A,80H+24    ; 24 bits
 3602 175B 90                      SUB      B           ; Bits to shift
 3603 175C CD1E15                  CALL     SCALE       ; Shift BCDE
 3604 175F 7C                      LD       A,H         ; Get combined sign
 3605 1760 17                      RLA                  ; Sign to carry
 3606 1761 DCF114                  CALL     C,FPROND    ; Negative - Round numb
 3607 1764 0600                    LD       B,0         ; Zero exponent
 3608 1766 DC0A15                  CALL     C,COMPL     ; If negative make posi
 3609 1769 E1                      POP      HL          ; Restore pointer to nu
 3610 176A C9                      RET
 3611                   ;
 3612 176B 1B           DCBCDE:    DEC      DE          ; Decrement BCDE
 3613 176C 7A                      LD       A,D         ; Test LSBs
 3614 176D A3                      AND      E
 3615 176E 3C                      INC      A
 3616 176F C0                      RET      NZ          ; Exit if LSBs not FFFF
 3617 1770 0B                      DEC      BC          ; Decrement MSBs
 3618 1771 C9                      RET
 3619                   ;
 3620 1772 212C81       INT:       LD       HL,FPEXP    ; Point to exponent
 3621 1775 7E                      LD       A,(HL)      ; Get exponent
 3622 1776 FE98                    CP       80H+24      ; Integer accuracy only
 3623 1778 3A2981                  LD       A,(FPREG)   ; Get LSB
 3624 177B D0                      RET      NC          ; Yes - Already integer
 3625 177C 7E                      LD       A,(HL)      ; Get exponent
 3626 177D CD4717                  CALL     FPINT       ; F.P to integer
 3627 1780 3698                    LD       (HL),80H+24 ; Save 24 bit integer
 3628 1782 7B                      LD       A,E         ; Get LSB of number
 3629 1783 F5                      PUSH     AF          ; Save LSB
 3630 1784 79                      LD       A,C         ; Get MSB of number
 3631 1785 17                      RLA                  ; Sign to carry
 3632 1786 CDA714                  CALL     CONPOS      ; Set sign of result
 3633 1789 F1                      POP      AF          ; Restore LSB of number
 3634 178A C9                      RET
 3635                   ;
 3636 178B 210000       MLDEBC:    LD       HL,0        ; Clear partial product
 3637 178E 78                      LD       A,B         ; Test multiplier
 3638 178F B1                      OR       C
 3639 1790 C8                      RET      Z           ; Return zero if zero
 3640 1791 3E10                    LD       A,16        ; 16 bits
 3641 1793 29           MLDBLP:    ADD      HL,HL       ; Shift P.P left
 3642 1794 DACB0F                  JP       C,BSERR     ; ?BS Error if overflow
 3643 1797 EB                      EX       DE,HL
 3644 1798 29                      ADD      HL,HL       ; Shift multiplier left
 3645 1799 EB                      EX       DE,HL
 3646 179A D2A117                  JP       NC,NOMLAD   ; Bit was zero - No add
 3647 179D 09                      ADD      HL,BC       ; Add multiplicand
 3648 179E DACB0F                  JP       C,BSERR     ; ?BS Error if overflow
 3649 17A1 3D           NOMLAD:    DEC      A           ; Count bits
 3650 17A2 C29317                  JP       NZ,MLDBLP   ; More
 3651 17A5 C9                      RET
 3652                   ;
 3653 17A6 FE2D         ASCTFP:    CP       '-'         ; Negative?
 3654 17A8 F5                      PUSH     AF          ; Save it and flags
 3655 17A9 CAB217                  JP       Z,CNVNUM    ; Yes - Convert number
 3656 17AC FE2B                    CP       '+'         ; Positive?
 3657 17AE CAB217                  JP       Z,CNVNUM    ; Yes - Convert number
 3658 17B1 2B                      DEC      HL          ; DEC 'cos GETCHR INCs
 3659 17B2 CDBF14       CNVNUM:    CALL     RESZER      ; Set result to zero
 3660 17B5 47                      LD       B,A         ; Digits after point co
 3661 17B6 57                      LD       D,A         ; Sign of exponent
 3662 17B7 5F                      LD       E,A         ; Exponent of ten
 3663 17B8 2F                      CPL
 3664 17B9 4F                      LD       C,A         ; Before or after point
 3665 17BA CD5008       MANLP:     CALL     GETCHR      ; Get next character
 3666 17BD DA0318                  JP       C,ADDIG     ; Digit - Add to number
 3667 17C0 FE2E                    CP       '.'
 3668 17C2 CADE17                  JP       Z,DPOINT    ; '.' - Flag point
 3669 17C5 FE45                    CP       'E'
 3670 17C7 C2E217                  JP       NZ,CONEXP   ; Not 'E' - Scale numbe
 3671 17CA CD5008                  CALL     GETCHR      ; Get next character
 3672 17CD CDF60D                  CALL     SGNEXP      ; Get sign of exponent
 3673 17D0 CD5008       EXPLP:     CALL     GETCHR      ; Get next character
 3674 17D3 DA2518                  JP       C,EDIGIT    ; Digit - Add to expone
 3675 17D6 14                      INC      D           ; Is sign negative?
 3676 17D7 C2E217                  JP       NZ,CONEXP   ; No - Scale number
 3677 17DA AF                      XOR      A
 3678 17DB 93                      SUB      E           ; Negate exponent
 3679 17DC 5F                      LD       E,A         ; And re-save it
 3680 17DD 0C                      INC      C           ; Flag end of number
 3681 17DE 0C           DPOINT:    INC      C           ; Flag point passed
 3682 17DF CABA17                  JP       Z,MANLP     ; Zero - Get another di
 3683 17E2 E5           CONEXP:    PUSH     HL          ; Save code string addr
 3684 17E3 7B                      LD       A,E         ; Get exponent
 3685 17E4 90                      SUB      B           ; Subtract digits after
 3686 17E5 F4FB17       SCALMI:    CALL     P,SCALPL    ; Positive - Multiply n
 3687 17E8 F2F117                  JP       P,ENDCON    ; Positive - All done
 3688 17EB F5                      PUSH     AF          ; Save number of times 
 3689 17EC CDE715                  CALL     DIV10       ; Divide by 10
 3690 17EF F1                      POP      AF          ; Restore count
 3691 17F0 3C                      INC      A           ; Count divides
 3692                   ;
 3693 17F1 C2E517       ENDCON:    JP       NZ,SCALMI   ; More to do
 3694 17F4 D1                      POP      DE          ; Restore code string a
 3695 17F5 F1                      POP      AF          ; Restore sign of numbe
 3696 17F6 CCC816                  CALL     Z,INVSGN    ; Negative - Negate num
 3697 17F9 EB                      EX       DE,HL       ; Code string address t
 3698 17FA C9                      RET
 3699                   ;
 3700 17FB C8           SCALPL:    RET      Z           ; Exit if no scaling ne
 3701 17FC F5           MULTEN:    PUSH     AF          ; Save count
 3702 17FD CD8816                  CALL     MLSP10      ; Multiply number by 10
 3703 1800 F1                      POP      AF          ; Restore count
 3704 1801 3D                      DEC      A           ; Count multiplies
 3705 1802 C9                      RET
 3706                   ;
 3707 1803 D5           ADDIG:     PUSH     DE          ; Save sign of exponent
 3708 1804 57                      LD       D,A         ; Save digit
 3709 1805 78                      LD       A,B         ; Get digits after poin
 3710 1806 89                      ADC      A,C         ; Add one if after poin
 3711 1807 47                      LD       B,A         ; Re-save counter
 3712 1808 C5                      PUSH     BC          ; Save point flags
 3713 1809 E5                      PUSH     HL          ; Save code string addr
 3714 180A D5                      PUSH     DE          ; Save digit
 3715 180B CD8816                  CALL     MLSP10      ; Multiply number by 10
 3716 180E F1                      POP      AF          ; Restore digit
 3717 180F D630                    SUB      '0'         ; Make it absolute
 3718 1811 CD1A18                  CALL     RSCALE      ; Re-scale number
 3719 1814 E1                      POP      HL          ; Restore code string a
 3720 1815 C1                      POP      BC          ; Restore point flags
 3721 1816 D1                      POP      DE          ; Restore sign of expon
 3722 1817 C3BA17                  JP       MANLP       ; Get another digit
 3723                   ;
 3724 181A CDD016       RSCALE:    CALL     STAKFP      ; Put number on stack
 3725 181D CDB116                  CALL     FLGREL      ; Digit to add to FPREG
 3726 1820 C1           PADD:      POP      BC          ; Restore number
 3727 1821 D1                      POP      DE
 3728 1822 C35914                  JP       FPADD       ; Add BCDE to FPREG and
 3729                   ;
 3730 1825 7B           EDIGIT:    LD       A,E         ; Get digit
 3731 1826 07                      RLCA                 ; Times 2
 3732 1827 07                      RLCA                 ; Times 4
 3733 1828 83                      ADD      A,E         ; Times 5
 3734 1829 07                      RLCA                 ; Times 10
 3735 182A 86                      ADD      A,(HL)      ; Add next digit
 3736 182B D630                    SUB      '0'         ; Make it absolute
 3737 182D 5F                      LD       E,A         ; Save new digit
 3738 182E C3D017                  JP       EXPLP       ; Look for another digi
 3739                   ;
 3740 1831 E5           LINEIN:    PUSH     HL          ; Save code string addr
 3741 1832 219003                  LD       HL,INMSG    ; Output " in "
 3742 1835 CD9611                  CALL     PRS         ; Output string at HL
 3743 1838 E1                      POP      HL          ; Restore code string a
 3744 1839 EB           PRNTHL:    EX       DE,HL       ; Code string address t
 3745 183A AF                      XOR      A
 3746 183B 0698                    LD       B,80H+24    ; 24 bits
 3747 183D CDB616                  CALL     RETINT      ; Return the integer
 3748 1840 219511                  LD       HL,PRNUMS   ; Print number string
 3749 1843 E5                      PUSH     HL          ; Save for return
 3750 1844 212E81       NUMASC:    LD       HL,PBUFF    ; Convert number to ASC
 3751 1847 E5                      PUSH     HL          ; Save for return
 3752 1848 CD9F16                  CALL     TSTSGN      ; Test sign of FPREG
 3753 184B 3620                    LD       (HL),' '    ; Space at start
 3754 184D F25218                  JP       P,SPCFST    ; Positive - Space to s
 3755 1850 362D                    LD       (HL),'-'    ; '-' sign at start
 3756 1852 23           SPCFST:    INC      HL          ; First byte of number
 3757 1853 3630                    LD       (HL),'0'    ; '0' if zero
 3758 1855 CA0819                  JP       Z,JSTZER    ; Return '0' if zero
 3759 1858 E5                      PUSH     HL          ; Save buffer address
 3760 1859 FCC816                  CALL     M,INVSGN    ; Negate FPREG if negat
 3761 185C AF                      XOR      A           ; Zero A
 3762 185D F5                      PUSH     AF          ; Save it
 3763 185E CD0E19                  CALL     RNGTST      ; Test number is in ran
 3764 1861 014391       SIXDIG:    LD       BC,9143H    ; BCDE - 99999.9
 3765 1864 11F84F                  LD       DE,4FF8H
 3766 1867 CD1A17                  CALL     CMPNUM      ; Compare numbers
 3767 186A B7                      OR       A
 3768 186B E27F18                  JP       PO,INRNG    ; > 99999.9 - Sort it o
 3769 186E F1                      POP      AF          ; Restore count
 3770 186F CDFC17                  CALL     MULTEN      ; Multiply by ten
 3771 1872 F5                      PUSH     AF          ; Re-save count
 3772 1873 C36118                  JP       SIXDIG      ; Test it again
 3773                   ;
 3774 1876 CDE715       GTSIXD:    CALL     DIV10       ; Divide by 10
 3775 1879 F1                      POP      AF          ; Get count
 3776 187A 3C                      INC      A           ; Count divides
 3777 187B F5                      PUSH     AF          ; Re-save count
 3778 187C CD0E19                  CALL     RNGTST      ; Test number is in ran
 3779 187F CD4714       INRNG:     CALL     ROUND       ; Add 0.5 to FPREG
 3780 1882 3C                      INC      A
 3781 1883 CD4717                  CALL     FPINT       ; F.P to integer
 3782 1886 CDE016                  CALL     FPBCDE      ; Move BCDE to FPREG
 3783 1889 010603                  LD       BC,0306H    ; 1E+06 to 1E-03 range
 3784 188C F1                      POP      AF          ; Restore count
 3785 188D 81                      ADD      A,C         ; 6 digits before point
 3786 188E 3C                      INC      A           ; Add one
 3787 188F FA9B18                  JP       M,MAKNUM    ; Do it in 'E' form if 
 3788 1892 FE08                    CP       6+1+1       ; More than 999999 ?
 3789 1894 D29B18                  JP       NC,MAKNUM   ; Yes - Do it in 'E' fo
 3790 1897 3C                      INC      A           ; Adjust for exponent
 3791 1898 47                      LD       B,A         ; Exponent of number
 3792 1899 3E02                    LD       A,2         ; Make it zero after
 3793                   ;
 3794 189B 3D           MAKNUM:    DEC      A           ; Adjust for digits to 
 3795 189C 3D                      DEC      A
 3796 189D E1                      POP      HL          ; Restore buffer addres
 3797 189E F5                      PUSH     AF          ; Save count
 3798 189F 112119                  LD       DE,POWERS   ; Powers of ten
 3799 18A2 05                      DEC      B           ; Count digits before p
 3800 18A3 C2AC18                  JP       NZ,DIGTXT   ; Not zero - Do number
 3801 18A6 362E                    LD       (HL),'.'    ; Save point
 3802 18A8 23                      INC      HL          ; Move on
 3803 18A9 3630                    LD       (HL),'0'    ; Save zero
 3804 18AB 23                      INC      HL          ; Move on
 3805 18AC 05           DIGTXT:    DEC      B           ; Count digits before p
 3806 18AD 362E                    LD       (HL),'.'    ; Save point in case
 3807 18AF CCF516                  CALL     Z,INCHL     ; Last digit - move on
 3808 18B2 C5                      PUSH     BC          ; Save digits before po
 3809 18B3 E5                      PUSH     HL          ; Save buffer address
 3810 18B4 D5                      PUSH     DE          ; Save powers of ten
 3811 18B5 CDEB16                  CALL     BCDEFP      ; Move FPREG to BCDE
 3812 18B8 E1                      POP      HL          ; Powers of ten table
 3813 18B9 062F                    LD       B, '0'-1    ; ASCII '0' - 1
 3814 18BB 04           TRYAGN:    INC      B           ; Count subtractions
 3815 18BC 7B                      LD       A,E         ; Get LSB
 3816 18BD 96                      SUB      (HL)        ; Subtract LSB
 3817 18BE 5F                      LD       E,A         ; Save LSB
 3818 18BF 23                      INC      HL
 3819 18C0 7A                      LD       A,D         ; Get NMSB
 3820 18C1 9E                      SBC      A,(HL)      ; Subtract NMSB
 3821 18C2 57                      LD       D,A         ; Save NMSB
 3822 18C3 23                      INC      HL
 3823 18C4 79                      LD       A,C         ; Get MSB
 3824 18C5 9E                      SBC      A,(HL)      ; Subtract MSB
 3825 18C6 4F                      LD       C,A         ; Save MSB
 3826 18C7 2B                      DEC      HL          ; Point back to start
 3827 18C8 2B                      DEC      HL
 3828 18C9 D2BB18                  JP       NC,TRYAGN   ; No overflow - Try aga
 3829 18CC CDFE14                  CALL     PLUCDE      ; Restore number
 3830 18CF 23                      INC      HL          ; Start of next number
 3831 18D0 CDE016                  CALL     FPBCDE      ; Move BCDE to FPREG
 3832 18D3 EB                      EX       DE,HL       ; Save point in table
 3833 18D4 E1                      POP      HL          ; Restore buffer addres
 3834 18D5 70                      LD       (HL),B      ; Save digit in buffer
 3835 18D6 23                      INC      HL          ; And move on
 3836 18D7 C1                      POP      BC          ; Restore digit count
 3837 18D8 0D                      DEC      C           ; Count digits
 3838 18D9 C2AC18                  JP       NZ,DIGTXT   ; More - Do them
 3839 18DC 05                      DEC      B           ; Any decimal part?
 3840 18DD CAEC18                  JP       Z,DOEBIT    ; No - Do 'E' bit
 3841 18E0 2B           SUPTLZ:    DEC      HL          ; Move back through buf
 3842 18E1 7E                      LD       A,(HL)      ; Get character
 3843 18E2 FE30                    CP       '0'         ; '0' character?
 3844 18E4 CAE018                  JP       Z,SUPTLZ    ; Yes - Look back for m
 3845 18E7 FE2E                    CP       '.'         ; A decimal point?
 3846 18E9 C4F516                  CALL     NZ,INCHL    ; Move back over digit
 3847                   ;
 3848 18EC F1           DOEBIT:    POP      AF          ; Get 'E' flag
 3849 18ED CA0B19                  JP       Z,NOENED    ; No 'E' needed - End b
 3850 18F0 3645                    LD       (HL),'E'    ; Put 'E' in buffer
 3851 18F2 23                      INC      HL          ; And move on
 3852 18F3 362B                    LD       (HL),'+'    ; Put '+' in buffer
 3853 18F5 F2FC18                  JP       P,OUTEXP    ; Positive - Output exp
 3854 18F8 362D                    LD       (HL),'-'    ; Put '-' in buffer
 3855 18FA 2F                      CPL                  ; Negate exponent
 3856 18FB 3C                      INC      A
 3857 18FC 062F         OUTEXP:    LD       B,'0'-1     ; ASCII '0' - 1
 3858 18FE 04           EXPTEN:    INC      B           ; Count subtractions
 3859 18FF D60A                    SUB      10          ; Tens digit
 3860 1901 D2FE18                  JP       NC,EXPTEN   ; More to do
 3861 1904 C63A                    ADD      A,'0'+10    ; Restore and make ASCI
 3862 1906 23                      INC      HL          ; Move on
 3863 1907 70                      LD       (HL),B      ; Save MSB of exponent
 3864 1908 23           JSTZER:    INC      HL          ;
 3865 1909 77                      LD       (HL),A      ; Save LSB of exponent
 3866 190A 23                      INC      HL
 3867 190B 71           NOENED:    LD       (HL),C      ; Mark end of buffer
 3868 190C E1                      POP      HL          ; Restore code string a
 3869 190D C9                      RET
 3870                   ;
 3871 190E 017494       RNGTST:    LD       BC,9474H    ; BCDE = 999999.
 3872 1911 11F723                  LD       DE,23F7H
 3873 1914 CD1A17                  CALL     CMPNUM      ; Compare numbers
 3874 1917 B7                      OR       A
 3875 1918 E1                      POP      HL          ; Return address to HL
 3876 1919 E27618                  JP       PO,GTSIXD   ; Too big - Divide by t
 3877 191C E9                      JP       (HL)        ; Otherwise return to c
 3878                   ;
 3879 191D 00000080     HALF:      DB       00H,00H,00H,80H ; 0.5
 3880                   ;
 3881 1921 A08601       POWERS:    DB       0A0H,086H,001H ; 100000
 3882 1924 102700                  DB       010H,027H,000H ; 10000
 3883 1927 E80300                  DB       0E8H,003H,000H ; 1000
 3884 192A 640000                  DB       064H,000H,000H ; 100
 3885 192D 0A0000                  DB       00AH,000H,000H ; 10
 3886 1930 010000                  DB       001H,000H,000H ; 1
 3887                   ;
 3888 1933 21C816       NEGAFT:    LD       HL,INVSGN   ; Negate result
 3889 1936 E3                      EX       (SP),HL     ; To be done after call
 3890 1937 E9                      JP       (HL)        ; Return to caller
 3891                   ;
 3892 1938 CDD016       SQR:       CALL     STAKFP      ; Put value on stack
 3893 193B 211D19                  LD       HL,HALF     ; Set power to 1/2
 3894 193E CDDD16                  CALL     PHLTFP      ; Move 1/2 to FPREG
 3895                   ;
 3896 1941 C1           POWER:     POP      BC          ; Get base
 3897 1942 D1                      POP      DE
 3898 1943 CD9F16                  CALL     TSTSGN      ; Test sign of power
 3899 1946 78                      LD       A,B         ; Get exponent of base
 3900 1947 CA8619                  JP       Z,EXP       ; Make result 1 if zero
 3901 194A F25119                  JP       P,POWER1    ; Positive base - Ok
 3902 194D B7                      OR       A           ; Zero to negative powe
 3903 194E CAFB03                  JP       Z,DZERR     ; Yes - ?/0 Error
 3904 1951 B7           POWER1:    OR       A           ; Base zero?
 3905 1952 CAC014                  JP       Z,SAVEXP    ; Yes - Return zero
 3906 1955 D5                      PUSH     DE          ; Save base
 3907 1956 C5                      PUSH     BC
 3908 1957 79                      LD       A,C         ; Get MSB of base
 3909 1958 F67F                    OR       01111111B   ; Get sign status
 3910 195A CDEB16                  CALL     BCDEFP      ; Move power to BCDE
 3911 195D F26E19                  JP       P,POWER2    ; Positive base - Ok
 3912 1960 D5                      PUSH     DE          ; Save power
 3913 1961 C5                      PUSH     BC
 3914 1962 CD7217                  CALL     INT         ; Get integer of power
 3915 1965 C1                      POP      BC          ; Restore power
 3916 1966 D1                      POP      DE
 3917 1967 F5                      PUSH     AF          ; MSB of base
 3918 1968 CD1A17                  CALL     CMPNUM      ; Power an integer?
 3919 196B E1                      POP      HL          ; Restore MSB of base
 3920 196C 7C                      LD       A,H         ; but don't affect flag
 3921 196D 1F                      RRA                  ; Exponent odd or even?
 3922 196E E1           POWER2:    POP      HL          ; Restore MSB and expon
 3923 196F 222B81                  LD       (FPREG+2),HL ; Save base in FPREG
 3924 1972 E1                      POP      HL          ; LSBs of base
 3925 1973 222981                  LD       (FPREG),HL  ; Save in FPREG
 3926 1976 DC3319                  CALL     C,NEGAFT    ; Odd power - Negate re
 3927 1979 CCC816                  CALL     Z,INVSGN    ; Negative base - Negat
 3928 197C D5                      PUSH     DE          ; Save power
 3929 197D C5                      PUSH     BC
 3930 197E CD5315                  CALL     LOG         ; Get LOG of base
 3931 1981 C1                      POP      BC          ; Restore power
 3932 1982 D1                      POP      DE
 3933 1983 CD9415                  CALL     FPMULT      ; Multiply LOG by power
 3934                   ;
 3935 1986 CDD016       EXP:       CALL     STAKFP      ; Put value on stack
 3936 1989 013881                  LD       BC,08138H   ; BCDE = 1/Ln(2)
 3937 198C 113BAA                  LD       DE,0AA3BH
 3938 198F CD9415                  CALL     FPMULT      ; Multiply value by 1/L
 3939 1992 3A2C81                  LD       A,(FPEXP)   ; Get exponent
 3940 1995 FE88                    CP       80H+8       ; Is it in range?
 3941 1997 D27B16                  JP       NC,OVTST1   ; No - Test for overflo
 3942 199A CD7217                  CALL     INT         ; Get INT of FPREG
 3943 199D C680                    ADD      A,80H       ; For excess 128
 3944 199F C602                    ADD      A,2         ; Exponent > 126?
 3945 19A1 DA7B16                  JP       C,OVTST1    ; Yes - Test for overfl
 3946 19A4 F5                      PUSH     AF          ; Save scaling factor
 3947 19A5 214215                  LD       HL,UNITY    ; Point to 1.
 3948 19A8 CD4A14                  CALL     ADDPHL      ; Add 1 to FPREG
 3949 19AB CD8B15                  CALL     MULLN2      ; Multiply by LN(2)
 3950 19AE F1                      POP      AF          ; Restore scaling facto
 3951 19AF C1                      POP      BC          ; Restore exponent
 3952 19B0 D1                      POP      DE
 3953 19B1 F5                      PUSH     AF          ; Save scaling factor
 3954 19B2 CD5614                  CALL     SUBCDE      ; Subtract exponent fro
 3955 19B5 CDC816                  CALL     INVSGN      ; Negate result
 3956 19B8 21C619                  LD       HL,EXPTAB   ; Coefficient table
 3957 19BB CDF619                  CALL     SMSER1      ; Sum the series
 3958 19BE 110000                  LD       DE,0        ; Zero LSBs
 3959 19C1 C1                      POP      BC          ; Scaling factor
 3960 19C2 4A                      LD       C,D         ; Zero MSB
 3961 19C3 C39415                  JP       FPMULT      ; Scale result to corre
 3962                   ;
 3963 19C6 08           EXPTAB:    DB       8           ; Table used by EXP
 3964 19C7 402E9474                DB       040H,02EH,094H,074H ; -1/7! (-1/504
 3965 19CB 704F2E77                DB       070H,04FH,02EH,077H ;  1/6! ( 1/720
 3966 19CF 6E02887A                DB       06EH,002H,088H,07AH ; -1/5! (-1/120
 3967 19D3 E6A02A7C                DB       0E6H,0A0H,02AH,07CH ;  1/4! ( 1/24)
 3968 19D7 50AAAA7E                DB       050H,0AAH,0AAH,07EH ; -1/3! (-1/6)
 3969 19DB FFFF7F7F                DB       0FFH,0FFH,07FH,07FH ;  1/2! ( 1/2)
 3970 19DF 00008081                DB       000H,000H,080H,081H ; -1/1! (-1/1)
 3971 19E3 00000081                DB       000H,000H,000H,081H ;  1/0! ( 1/1)
 3972                   ;
 3973 19E7 CDD016       SUMSER:    CALL     STAKFP      ; Put FPREG on stack
 3974 19EA 119215                  LD       DE,MULT     ; Multiply by "X"
 3975 19ED D5                      PUSH     DE          ; To be done after
 3976 19EE E5                      PUSH     HL          ; Save address of table
 3977 19EF CDEB16                  CALL     BCDEFP      ; Move FPREG to BCDE
 3978 19F2 CD9415                  CALL     FPMULT      ; Square the value
 3979 19F5 E1                      POP      HL          ; Restore address of ta
 3980 19F6 CDD016       SMSER1:    CALL     STAKFP      ; Put value on stack
 3981 19F9 7E                      LD       A,(HL)      ; Get number of coeffic
 3982 19FA 23                      INC      HL          ; Point to start of tab
 3983 19FB CDDD16                  CALL     PHLTFP      ; Move coefficient to F
 3984 19FE 06                      DB       06H         ; Skip "POP AF"
 3985 19FF F1           SUMLP:     POP      AF          ; Restore count
 3986 1A00 C1                      POP      BC          ; Restore number
 3987 1A01 D1                      POP      DE
 3988 1A02 3D                      DEC      A           ; Cont coefficients
 3989 1A03 C8                      RET      Z           ; All done
 3990 1A04 D5                      PUSH     DE          ; Save number
 3991 1A05 C5                      PUSH     BC
 3992 1A06 F5                      PUSH     AF          ; Save count
 3993 1A07 E5                      PUSH     HL          ; Save address in table
 3994 1A08 CD9415                  CALL     FPMULT      ; Multiply FPREG by BCD
 3995 1A0B E1                      POP      HL          ; Restore address in ta
 3996 1A0C CDEE16                  CALL     LOADFP      ; Number at HL to BCDE
 3997 1A0F E5                      PUSH     HL          ; Save address in table
 3998 1A10 CD5914                  CALL     FPADD       ; Add coefficient to FP
 3999 1A13 E1                      POP      HL          ; Restore address in ta
 4000 1A14 C3FF19                  JP       SUMLP       ; More coefficients
 4001                   ;
 4002 1A17 CD9F16       RND:       CALL     TSTSGN      ; Test sign of FPREG
 4003 1A1A 215E80                  LD       HL,SEED+2   ; Random number seed
 4004 1A1D FA781A                  JP       M,RESEED    ; Negative - Re-seed
 4005 1A20 217F80                  LD       HL,LSTRND   ; Last random number
 4006 1A23 CDDD16                  CALL     PHLTFP      ; Move last RND to FPRE
 4007 1A26 215E80                  LD       HL,SEED+2   ; Random number seed
 4008 1A29 C8                      RET      Z           ; Return if RND(0)
 4009 1A2A 86                      ADD      A,(HL)      ; Add (SEED)+2)
 4010 1A2B E607                    AND      00000111B   ; 0 to 7
 4011 1A2D 0600                    LD       B,0
 4012 1A2F 77                      LD       (HL),A      ; Re-save seed
 4013 1A30 23                      INC      HL          ; Move to coefficient t
 4014 1A31 87                      ADD      A,A         ; 4 bytes
 4015 1A32 87                      ADD      A,A         ; per entry
 4016 1A33 4F                      LD       C,A         ; BC = Offset into tabl
 4017 1A34 09                      ADD      HL,BC       ; Point to coefficient
 4018 1A35 CDEE16                  CALL     LOADFP      ; Coefficient to BCDE
 4019 1A38 CD9415                  CALL     FPMULT      ;       ; Multiply FPRE
 4020 1A3B 3A5D80                  LD       A,(SEED+1)  ; Get (SEED+1)
 4021 1A3E 3C                      INC      A           ; Add 1
 4022 1A3F E603                    AND      00000011B   ; 0 to 3
 4023 1A41 0600                    LD       B,0
 4024 1A43 FE01                    CP       1           ; Is it zero?
 4025 1A45 88                      ADC      A,B         ; Yes - Make it 1
 4026 1A46 325D80                  LD       (SEED+1),A  ; Re-save seed
 4027 1A49 217C1A                  LD       HL,RNDTAB-4 ; Addition table
 4028 1A4C 87                      ADD      A,A         ; 4 bytes
 4029 1A4D 87                      ADD      A,A         ; per entry
 4030 1A4E 4F                      LD       C,A         ; BC = Offset into tabl
 4031 1A4F 09                      ADD      HL,BC       ; Point to value
 4032 1A50 CD4A14                  CALL     ADDPHL      ; Add value to FPREG
 4033 1A53 CDEB16       RND1:      CALL     BCDEFP      ; Move FPREG to BCDE
 4034 1A56 7B                      LD       A,E         ; Get LSB
 4035 1A57 59                      LD       E,C         ; LSB = MSB
 4036 1A58 EE4F                    XOR      01001111B   ; Fiddle around
 4037 1A5A 4F                      LD       C,A         ; New MSB
 4038 1A5B 3680                    LD       (HL),80H    ; Set exponent
 4039 1A5D 2B                      DEC      HL          ; Point to MSB
 4040 1A5E 46                      LD       B,(HL)      ; Get MSB
 4041 1A5F 3680                    LD       (HL),80H    ; Make value -0.5
 4042 1A61 215C80                  LD       HL,SEED     ; Random number seed
 4043 1A64 34                      INC      (HL)        ; Count seed
 4044 1A65 7E                      LD       A,(HL)      ; Get seed
 4045 1A66 D6AB                    SUB      171         ; Do it modulo 171
 4046 1A68 C26F1A                  JP       NZ,RND2     ; Non-zero - Ok
 4047 1A6B 77                      LD       (HL),A      ; Zero seed
 4048 1A6C 0C                      INC      C           ; Fillde about
 4049 1A6D 15                      DEC      D           ; with the
 4050 1A6E 1C                      INC      E           ; number
 4051 1A6F CDAA14       RND2:      CALL     BNORM       ; Normalise number
 4052 1A72 217F80                  LD       HL,LSTRND   ; Save random number
 4053 1A75 C3F716                  JP       FPTHL       ; Move FPREG to last an
 4054                   ;
 4055 1A78 77           RESEED:    LD       (HL),A      ; Re-seed random number
 4056 1A79 2B                      DEC      HL
 4057 1A7A 77                      LD       (HL),A
 4058 1A7B 2B                      DEC      HL
 4059 1A7C 77                      LD       (HL),A
 4060 1A7D C3531A                  JP       RND1        ; Return RND seed
 4061                   ;
 4062 1A80 68B14668     RNDTAB:    DB       068H,0B1H,046H,068H ; Table used by
 4063 1A84 99E99269                DB       099H,0E9H,092H,069H
 4064 1A88 10D17568                DB       010H,0D1H,075H,068H
 4065                   ;
 4066 1A8C 21D61A       COS:       LD       HL,HALFPI   ; Point to PI/2
 4067 1A8F CD4A14                  CALL     ADDPHL      ; Add it to PPREG
 4068 1A92 CDD016       SIN:       CALL     STAKFP      ; Put angle on stack
 4069 1A95 014983                  LD       BC,8349H    ; BCDE = 2 PI
 4070 1A98 11DB0F                  LD       DE,0FDBH
 4071 1A9B CDE016                  CALL     FPBCDE      ; Move 2 PI to FPREG
 4072 1A9E C1                      POP      BC          ; Restore angle
 4073 1A9F D1                      POP      DE
 4074 1AA0 CDF515                  CALL     DVBCDE      ; Divide angle by 2 PI
 4075 1AA3 CDD016                  CALL     STAKFP      ; Put it on stack
 4076 1AA6 CD7217                  CALL     INT         ; Get INT of result
 4077 1AA9 C1                      POP      BC          ; Restore number
 4078 1AAA D1                      POP      DE
 4079 1AAB CD5614                  CALL     SUBCDE      ; Make it 0 <= value < 
 4080 1AAE 21DA1A                  LD       HL,QUARTR   ; Point to 0.25
 4081 1AB1 CD5014                  CALL     SUBPHL      ; Subtract value from 0
 4082 1AB4 CD9F16                  CALL     TSTSGN      ; Test sign of value
 4083 1AB7 37                      SCF                  ; Flag positive
 4084 1AB8 F2C21A                  JP       P,SIN1      ; Positive - Ok
 4085 1ABB CD4714                  CALL     ROUND       ; Add 0.5 to value
 4086 1ABE CD9F16                  CALL     TSTSGN      ; Test sign of value
 4087 1AC1 B7                      OR       A           ; Flag negative
 4088 1AC2 F5           SIN1:      PUSH     AF          ; Save sign
 4089 1AC3 F4C816                  CALL     P,INVSGN    ; Negate value if posit
 4090 1AC6 21DA1A                  LD       HL,QUARTR   ; Point to 0.25
 4091 1AC9 CD4A14                  CALL     ADDPHL      ; Add 0.25 to value
 4092 1ACC F1                      POP      AF          ; Restore sign
 4093 1ACD D4C816                  CALL     NC,INVSGN   ; Negative - Make posit
 4094 1AD0 21DE1A                  LD       HL,SINTAB   ; Coefficient table
 4095 1AD3 C3E719                  JP       SUMSER      ; Evaluate sum of serie
 4096                   ;
 4097 1AD6 DB0F4981     HALFPI:    DB       0DBH,00FH,049H,081H ; 1.5708 (PI/2)
 4098                   ;
 4099 1ADA 0000007F     QUARTR:    DB       000H,000H,000H,07FH ; 0.25
 4100                   ;
 4101 1ADE 05           SINTAB:    DB       5           ; Table used by SIN
 4102 1ADF BAD71E86                DB       0BAH,0D7H,01EH,086H ; 39.711
 4103 1AE3 64269987                DB       064H,026H,099H,087H ;-76.575
 4104 1AE7 58342387                DB       058H,034H,023H,087H ; 81.602
 4105 1AEB E05DA586                DB       0E0H,05DH,0A5H,086H ;-41.342
 4106 1AEF DA0F4983                DB       0DAH,00FH,049H,083H ; 6.2832
 4107                   ;
 4108 1AF3 CDD016       TAN:       CALL     STAKFP      ; Put angle on stack
 4109 1AF6 CD921A                  CALL     SIN         ; Get SIN of angle
 4110 1AF9 C1                      POP      BC          ; Restore angle
 4111 1AFA E1                      POP      HL
 4112 1AFB CDD016                  CALL     STAKFP      ; Save SIN of angle
 4113 1AFE EB                      EX       DE,HL       ; BCDE = Angle
 4114 1AFF CDE016                  CALL     FPBCDE      ; Angle to FPREG
 4115 1B02 CD8C1A                  CALL     COS         ; Get COS of angle
 4116 1B05 C3F315                  JP       DIV         ; TAN = SIN / COS
 4117                   ;
 4118 1B08 CD9F16       ATN:       CALL     TSTSGN      ; Test sign of value
 4119 1B0B FC3319                  CALL     M,NEGAFT    ; Negate result after i
 4120 1B0E FCC816                  CALL     M,INVSGN    ; Negate value if -ve
 4121 1B11 3A2C81                  LD       A,(FPEXP)   ; Get exponent
 4122 1B14 FE81                    CP       81H         ; Number less than 1?
 4123 1B16 DA251B                  JP       C,ATN1      ; Yes - Get arc tangnt
 4124 1B19 010081                  LD       BC,8100H    ; BCDE = 1
 4125 1B1C 51                      LD       D,C
 4126 1B1D 59                      LD       E,C
 4127 1B1E CDF515                  CALL     DVBCDE      ; Get reciprocal of num
 4128 1B21 215014                  LD       HL,SUBPHL   ; Sub angle from PI/2
 4129 1B24 E5                      PUSH     HL          ; Save for angle > 1
 4130 1B25 212F1B       ATN1:      LD       HL,ATNTAB   ; Coefficient table
 4131 1B28 CDE719                  CALL     SUMSER      ; Evaluate sum of serie
 4132 1B2B 21D61A                  LD       HL,HALFPI   ; PI/2 - angle in case 
 4133 1B2E C9                      RET                  ; Number > 1 - Sub from
 4134                   ;
 4135 1B2F 09           ATNTAB:    DB       9           ; Table used by ATN
 4136 1B30 4AD73B78                DB       04AH,0D7H,03BH,078H ; 1/17
 4137 1B34 026E847B                DB       002H,06EH,084H,07BH ;-1/15
 4138 1B38 FEC12F7C                DB       0FEH,0C1H,02FH,07CH ; 1/13
 4139 1B3C 74319A7D                DB       074H,031H,09AH,07DH ;-1/11
 4140 1B40 843D5A7D                DB       084H,03DH,05AH,07DH ; 1/9
 4141 1B44 C87F917E                DB       0C8H,07FH,091H,07EH ;-1/7
 4142 1B48 E4BB4C7E                DB       0E4H,0BBH,04CH,07EH ; 1/5
 4143 1B4C 6CAAAA7F                DB       06CH,0AAH,0AAH,07FH ;-1/3
 4144 1B50 00000081                DB       000H,000H,000H,081H ; 1/1
 4145                   ;
 4146                   
 4147 1B54 C9           ARET:      RET                  ; A RETurn instruction
 4148                   ;
 4149 1B55 D7           GETINP:    RST      10H         ;input a character
 4150 1B56 C9                      RET
 4151                   ;
 4152 1B57              CLS:
 4153 1B57 3E0C                    LD       A,CS        ; ASCII Clear screen
 4154 1B59 C38D1C                  JP       MONOUT      ; Output character
 4155                   ;
 4156 1B5C CD1E14       WIDTH:     CALL     GETINT      ; Get integer 0-255
 4157 1B5F 7B                      LD       A,E         ; Width to A
 4158 1B60 328780                  LD       (LWIDTH),A  ; Set width
 4159 1B63 C9                      RET
 4160                   ;
 4161 1B64 CDBD0C       LINES:     CALL     GETNUM      ; Get a number
 4162 1B67 CD0209                  CALL     DEINT       ; Get integer -32768 to
 4163 1B6A ED538B80                LD       (LINESC),DE ; Set lines counter
 4164 1B6E ED538D80                LD       (LINESN),DE ; Set lines number
 4165 1B72 C9                      RET
 4166                   ;
 4167 1B73 CD0209       DEEK:      CALL     DEINT       ; Get integer -32768 to
 4168 1B76 D5                      PUSH     DE          ; Save number
 4169 1B77 E1                      POP      HL          ; Number to HL
 4170 1B78 46                      LD       B,(HL)      ; Get LSB of contents
 4171 1B79 23                      INC      HL
 4172 1B7A 7E                      LD       A,(HL)      ; Get MSB of contents
 4173 1B7B C37810                  JP       ABPASS      ; Return integer AB
 4174                   ;
 4175 1B7E CDBD0C       DOKE:      CALL     GETNUM      ; Get a number
 4176 1B81 CD0209                  CALL     DEINT       ; Get integer -32768 to
 4177 1B84 D5                      PUSH     DE          ; Save address
 4178 1B85 CDC606                  CALL     CHKSYN      ; Make sure ',' follows
 4179 1B88 2C                      DB       ','
 4180 1B89 CDBD0C                  CALL     GETNUM      ; Get a number
 4181 1B8C CD0209                  CALL     DEINT       ; Get integer -32768 to
 4182 1B8F E3                      EX       (SP),HL     ; Save value,get addres
 4183 1B90 73                      LD       (HL),E      ; Save LSB of value
 4184 1B91 23                      INC      HL
 4185 1B92 72                      LD       (HL),D      ; Save MSB of value
 4186 1B93 E1                      POP      HL          ; Restore code string a
 4187 1B94 C9                      RET
 4188                   ;
 4189                   
 4190                   ; HEX$(nn) Convert 16 bit number to Hexadecimal string
 4191                   ;
 4192 1B95 CDC00C       HEX:       CALL     TSTNUM      ; Verify it's a number
 4193 1B98 CD0209                  CALL     DEINT       ; Get integer -32768 to
 4194 1B9B C5                      PUSH     BC          ; Save contents of BC
 4195 1B9C 212E81                  LD       HL,PBUFF
 4196 1B9F 7A                      LD       A,D         ; Get high order into A
 4197 1BA0 FE00                    CP       0
 4198 1BA2 280C                    JR       Z,HEX2      ; Skip output if both h
 4199 1BA4 CDCD1B                  CALL     BYT2ASC     ; Convert D to ASCII
 4200 1BA7 78                      LD       A,B
 4201 1BA8 FE30                    CP       '0'
 4202 1BAA 2802                    JR       Z,HEX1      ; Don't store high digi
 4203 1BAC 70                      LD       (HL),B      ; Store it to PBUFF
 4204 1BAD 23                      INC      HL          ; Next location
 4205 1BAE 71           HEX1:      LD       (HL),C      ; Store C to PBUFF+1
 4206 1BAF 23                      INC      HL          ; Next location
 4207 1BB0 7B           HEX2:      LD       A,E         ; Get lower byte
 4208 1BB1 CDCD1B                  CALL     BYT2ASC     ; Convert E to ASCII
 4209 1BB4 7A                      LD       A,D
 4210 1BB5 FE00                    CP       0
 4211 1BB7 2005                    JR       NZ,HEX3     ; If upper byte was not
 4212 1BB9 78                      LD       A,B
 4213 1BBA FE30                    CP       '0'         ; If high digit of lowe
 4214 1BBC 2802                    JR       Z,HEX4
 4215 1BBE 70           HEX3:      LD       (HL),B      ; to PBUFF+2
 4216 1BBF 23                      INC      HL          ; Next location
 4217 1BC0 71           HEX4:      LD       (HL),C      ; to PBUFF+3
 4218 1BC1 23                      INC      HL          ; PBUFF+4 to zero
 4219 1BC2 AF                      XOR      A           ; Terminating character
 4220 1BC3 77                      LD       (HL),A      ; Store zero to termina
 4221 1BC4 23                      INC      HL          ; Make sure PBUFF is te
 4222 1BC5 77                      LD       (HL),A      ; Store the double zero
 4223 1BC6 C1                      POP      BC          ; Get BC back
 4224 1BC7 212E81                  LD       HL,PBUFF    ; Reset to start of PBU
 4225 1BCA C32611                  JP       STR1        ; Convert the PBUFF to 
 4226                   ;
 4227 1BCD 47           BYT2ASC    LD       B,A         ; Save original value
 4228 1BCE E60F                    AND      0FH         ; Strip off upper nybbl
 4229 1BD0 FE0A                    CP       0AH         ; 0-9?
 4230 1BD2 3802                    JR       C,ADD30     ; If A-F, add 7 more
 4231 1BD4 C607                    ADD      A,07H       ; Bring value up to ASC
 4232 1BD6 C630         ADD30      ADD      A,30H       ; And make ASCII
 4233 1BD8 4F                      LD       C,A         ; Save converted char t
 4234 1BD9 78                      LD       A,B         ; Retrieve original val
 4235 1BDA 0F                      RRCA                 ; and Rotate it right
 4236 1BDB 0F                      RRCA
 4237 1BDC 0F                      RRCA
 4238 1BDD 0F                      RRCA
 4239 1BDE E60F                    AND      0FH         ; Mask off upper nybble
 4240 1BE0 FE0A                    CP       0AH         ; 0-9? < A hex?
 4241 1BE2 3802                    JR       C,ADD301    ; Skip Add 7
 4242 1BE4 C607                    ADD      A,07H       ; Bring it up to ASCII 
 4243 1BE6 C630         ADD301     ADD      A,30H       ; And make it full ASCI
 4244 1BE8 47                      LD       B,A         ; Store high order byte
 4245 1BE9 C9                      RET
 4246                   ;
 4247                   ; Convert "&Hnnnn" to FPREG
 4248                   ; Gets a character from (HL) checks for Hexadecimal ASC
 4249                   ; Char is in A, NC if char is;<=>?@ A-z, CY is set if 0
 4250 1BEA EB           HEXTFP     EX       DE,HL       ; Move code string poin
 4251 1BEB 210000                  LD       HL,0000H    ; Zero out the value
 4252 1BEE CD031C                  CALL     GETHEX      ; Check the number for 
 4253 1BF1 DA231C                  JP       C,HXERR     ; First value wasn't he
 4254 1BF4 1805                    JR       HEXLP1      ; Convert first charact
 4255 1BF6 CD031C       HEXLP      CALL     GETHEX      ; Get second and addtio
 4256 1BF9 381F                    JR       C,HEXIT     ; Exit if not a hex cha
 4257 1BFB 29           HEXLP1     ADD      HL,HL       ; Rotate 4 bits to the 
 4258 1BFC 29                      ADD      HL,HL
 4259 1BFD 29                      ADD      HL,HL
 4260 1BFE 29                      ADD      HL,HL
 4261 1BFF B5                      OR       L           ; Add in D0-D3 into L
 4262 1C00 6F                      LD       L,A         ; Save new value
 4263 1C01 18F3                    JR       HEXLP       ; And continue until al
 4264                   ;
 4265 1C03 13           GETHEX     INC      DE          ; Next location
 4266 1C04 1A                      LD       A,(DE)      ; Load character at poi
 4267 1C05 FE20                    CP       ' '
 4268 1C07 CA031C                  JP       Z,GETHEX    ; Skip spaces
 4269 1C0A D630                    SUB      30H         ; Get absolute value
 4270 1C0C D8                      RET      C           ; < "0", error
 4271 1C0D FE0A                    CP       0AH
 4272 1C0F 3805                    JR       C,NOSUB7    ; Is already in the ran
 4273 1C11 D607                    SUB      07H         ; Reduce to A-F
 4274 1C13 FE0A                    CP       0AH         ; Value should be $0A-$
 4275 1C15 D8                      RET      C           ; CY set if was :      
 4276 1C16 FE10         NOSUB7     CP       10H         ; > Greater than "F"?
 4277 1C18 3F                      CCF
 4278 1C19 C9                      RET                  ; CY set if it wasn't v
 4279                   
 4280 1C1A EB           HEXIT      EX       DE,HL       ; Value into DE, Code s
 4281 1C1B 7A                      LD       A,D         ; Load DE into AC
 4282 1C1C 4B                      LD       C,E         ; For prep to
 4283 1C1D E5                      PUSH     HL
 4284 1C1E CD7710                  CALL     ACPASS      ; ACPASS to set AC as i
 4285 1C21 E1                      POP      HL
 4286 1C22 C9                      RET
 4287                   ;
 4288 1C23 1E26         HXERR:     LD       E,HX        ; ?HEX Error
 4289 1C25 C30C04                  JP       ERROR
 4290                   ;
 4291                   ; BIN$(NN) Convert integer to a 1-16 char binary string
 4292 1C28 CDC00C       BIN:       CALL     TSTNUM      ; Verify it's a number
 4293 1C2B CD0209                  CALL     DEINT       ; Get integer -32768 to
 4294 1C2E C5           BIN2:      PUSH     BC          ; Save contents of BC
 4295 1C2F 212E81                  LD       HL,PBUFF
 4296 1C32 0611                    LD       B,17        ; One higher than max c
 4297 1C34              ZEROSUP:                        ; Suppress leading zero
 4298 1C34 05                      DEC      B           ; Max 16 chars
 4299 1C35 78                      LD       A,B
 4300 1C36 FE01                    CP       01H
 4301 1C38 2808                    JR       Z,BITOUT    ; Always output at leas
 4302 1C3A CB13                    RL       E
 4303 1C3C CB12                    RL       D
 4304 1C3E 30F4                    JR       NC,ZEROSUP
 4305 1C40 1804                    JR       BITOUT2
 4306 1C42              BITOUT:
 4307 1C42 CB13                    RL       E
 4308 1C44 CB12                    RL       D           ; Top bit now in carry
 4309 1C46              BITOUT2:
 4310 1C46 3E30                    LD       A,'0'       ; Char for '0'
 4311 1C48 CE00                    ADC      A,0         ; If carry set then '0'
 4312 1C4A 77                      LD       (HL),A
 4313 1C4B 23                      INC      HL
 4314 1C4C 05                      DEC      B
 4315 1C4D 20F3                    JR       NZ,BITOUT
 4316 1C4F AF                      XOR      A           ; Terminating character
 4317 1C50 77                      LD       (HL),A      ; Store zero to termina
 4318 1C51 23                      INC      HL          ; Make sure PBUFF is te
 4319 1C52 77                      LD       (HL),A      ; Store the double zero
 4320 1C53 C1                      POP      BC
 4321 1C54 212E81                  LD       HL,PBUFF
 4322 1C57 C32611                  JP       STR1
 4323                   ;
 4324                   ; Convert "&Bnnnn" to FPREG
 4325                   ; Gets a character from (HL) checks for Binary ASCII nu
 4326 1C5A EB           BINTFP:    EX       DE,HL       ; Move code string poin
 4327 1C5B 210000                  LD       HL,0000H    ; Zero out the value
 4328 1C5E CD771C                  CALL     CHKBIN      ; Check the number for 
 4329 1C61 DA851C                  JP       C,BINERR    ; First value wasn't bi
 4330 1C64 D630         BINIT:     SUB      '0'
 4331 1C66 29                      ADD      HL,HL       ; Rotate HL left
 4332 1C67 B5                      OR       L
 4333 1C68 6F                      LD       L,A
 4334 1C69 CD771C                  CALL     CHKBIN      ; Get second and addtio
 4335 1C6C 30F6                    JR       NC,BINIT    ; Process if a bin char
 4336 1C6E EB                      EX       DE,HL       ; Value into DE, Code s
 4337 1C6F 7A                      LD       A,D         ; Load DE into AC
 4338 1C70 4B                      LD       C,E         ; For prep to
 4339 1C71 E5                      PUSH     HL
 4340 1C72 CD7710                  CALL     ACPASS      ; ACPASS to set AC as i
 4341 1C75 E1                      POP      HL
 4342 1C76 C9                      RET
 4343                   ;
 4344                   ; Char is in A, NC if char is 0 or 1
 4345 1C77 13           CHKBIN:    INC      DE
 4346 1C78 1A                      LD       A,(DE)
 4347 1C79 FE20                    CP       ' '
 4348 1C7B CA771C                  JP       Z,CHKBIN    ; Skip spaces
 4349 1C7E FE30                    CP       '0'         ; Set C if < '0'
 4350 1C80 D8                      RET      C
 4351 1C81 FE32                    CP       '2'
 4352 1C83 3F                      CCF                  ; Set C if > '1'
 4353 1C84 C9                      RET
 4354                   ;
 4355 1C85 1E28         BINERR:    LD       E,BN        ; ?BIN Error
 4356 1C87 C30C04                  JP       ERROR
 4357                   ;
 4358 1C8A C35100       JJUMP1:    JP       CSTART      ; Go and initialise
 4359                   ;
 4360 1C8D C30800       MONOUT:    JP       0008H       ; output a char
 4361                   ;
 4362 1C90 C30000       MONITR:    JP       0000H       ; Restart (Normally Mon
 4363                   ;
 4364 1C93 3E00         INITST:    LD       A,0         ; Clear break flag
 4365 1C95 329280                  LD       (BRKFLG),A
 4366 1C98 C35800                  JP       INIT
 4367                   ;
 4368 1C9B F5           TSTBIT:    PUSH     AF          ; Save bit mask
 4369 1C9C A0                      AND      B           ; Get common bits
 4370 1C9D C1                      POP      BC          ; Restore bit mask
 4371 1C9E B8                      CP       B           ; Same bit set?
 4372 1C9F 3E00                    LD       A,0         ; Return 0 in A
 4373 1CA1 C9                      RET
 4374                   ;
 4375 1CA2 CDD106       OUTNCR:    CALL     OUTC        ; Output character in A
 4376 1CA5 C3F80A                  JP       PRCRLF      ; Output CRLF
 4377                   ;
 4378 1CA8                         END
